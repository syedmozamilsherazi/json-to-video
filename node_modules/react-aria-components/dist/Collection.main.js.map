{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;CAUC;;;;AA4BM,MAAM;IAsBX,IAAI,aAAgC;QAClC,MAAM,IAAI,MAAM;IAClB;IAEA,QAAsB;QACpB,IAAI,OAA8B,IAAI,0CAAU,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG;QACnE,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,QAAQ,GAAG,IAAI,CAAC,QAAQ;QAC7B,KAAK,SAAS,GAAG,IAAI,CAAC,SAAS;QAC/B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,SAAS,GAAG,IAAI,CAAC,SAAS;QAC/B,KAAK,OAAO,GAAG,IAAI,CAAC,OAAO;QAC3B,KAAK,OAAO,GAAG,IAAI,CAAC,OAAO;QAC3B,KAAK,aAAa,GAAG,IAAI,CAAC,aAAa;QACvC,KAAK,YAAY,GAAG,IAAI,CAAC,YAAY;QACrC,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,OAAO;IACT;IAzBA,YAAY,IAAY,EAAE,GAAQ,CAAE;aAd3B,QAAkB;aAClB,QAAgB;aAChB,gBAAyB;aACzB,WAAsB;aACtB,YAAoB;aACpB,gBAAwB;aACxB,QAAgB;aAChB,YAAwB;aACxB,UAAsB;aACtB,UAAsB;aACtB,gBAA4B;aAC5B,eAA2B;aAC3B,QAAa,CAAC;QAGrB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,GAAG,GAAG;IACb;AAuBF;AAEA;;;CAGC,GACD,MAAM;IAYJ,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAG;QACnB,IAAI,OAAO,IAAI,CAAC,UAAU;QAC1B,MAAO,KAAM;YACX,MAAM;YACN,OAAO,KAAK,WAAW;QACzB;IACF;IAEA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA,IAAI,WAAW,UAAU,EAAE;QACzB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA,IAAI,UAAU,SAAS,EAAE;QACvB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,kBAAkB;QACpB,OAAO,IAAI,CAAC,gBAAgB;IAC9B;IAEA,IAAI,gBAAgB,eAAe,EAAE;QACnC,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,cAAc;QAChB,OAAO,IAAI,CAAC,YAAY;IAC1B;IAEA,IAAI,YAAY,WAAW,EAAE;QAC3B,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,WAAW;IACzB;IAEA,IAAI,WAAW,UAAU,EAAE;QACzB,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,cAAc;YACT;QAAP,OAAO,EAAA,mBAAA,IAAI,CAAC,UAAU,cAAf,uCAAA,iBAAiB,WAAW,KAAI;IACzC;IAEA,YAAY,KAAqB,EAAE;QACjC,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACnC,IAAI,MAAM,UAAU,EAClB,MAAM,UAAU,CAAC,WAAW,CAAC;QAG/B,IAAI,IAAI,CAAC,UAAU,IAAI,MACrB,IAAI,CAAC,UAAU,GAAG;QAGpB,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG;YAC7B,MAAM,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;YACrC,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS;QACxC,OAAO;YACL,MAAM,eAAe,GAAG;YACxB,MAAM,KAAK,GAAG;QAChB;QAEA,MAAM,UAAU,GAAG,IAAI;QACvB,MAAM,WAAW,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG;QAEjB,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;QACjC,IAAI,MAAM,WAAW,EACnB,2EAA2E;QAC3E,oEAAoE;QACpE,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC;QAG7B,IAAI,CAAC,aAAa,CAAC,cAAc;QACjC,IAAI,CAAC,aAAa,CAAC,WAAW;IAChC;IAEA,aAAa,OAAuB,EAAE,aAA6B,EAAE;QACnE,IAAI,iBAAiB,MACnB,OAAO,IAAI,CAAC,WAAW,CAAC;QAG1B,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACnC,IAAI,QAAQ,UAAU,EACpB,QAAQ,UAAU,CAAC,WAAW,CAAC;QAGjC,QAAQ,WAAW,GAAG;QACtB,QAAQ,eAAe,GAAG,cAAc,eAAe;QACvD,QAAQ,KAAK,GAAG,cAAc,KAAK;QAEnC,IAAI,IAAI,CAAC,UAAU,KAAK,eACtB,IAAI,CAAC,UAAU,GAAG;aACb,IAAI,cAAc,eAAe,EACtC,cAAc,eAAe,CAAC,WAAW,GAAG;QAG9C,cAAc,eAAe,GAAG;QAChC,QAAQ,UAAU,GAAG,cAAc,UAAU;QAE7C,IAAI,OAA8B;QAClC,MAAO,KAAM;YACX,KAAK,KAAK;YACV,OAAO,KAAK,WAAW;QACzB;QAEA,IAAI,QAAQ,WAAW,EACrB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC;QAG7B,IAAI,CAAC,aAAa,CAAC,cAAc;QACjC,IAAI,CAAC,aAAa,CAAC,WAAW;IAChC;IAEA,YAAY,KAAqB,EAAE;QACjC,IAAI,MAAM,UAAU,KAAK,IAAI,EAC3B;QAGF,IAAI,CAAC,aAAa,CAAC,gBAAgB;QACnC,IAAI,OAAO,MAAM,WAAW;QAC5B,MAAO,KAAM;YACX,KAAK,KAAK;YACV,OAAO,KAAK,WAAW;QACzB;QAEA,IAAI,MAAM,WAAW,EACnB,MAAM,WAAW,CAAC,eAAe,GAAG,MAAM,eAAe;QAG3D,IAAI,MAAM,eAAe,EACvB,MAAM,eAAe,CAAC,WAAW,GAAG,MAAM,WAAW;QAGvD,IAAI,IAAI,CAAC,UAAU,KAAK,OACtB,IAAI,CAAC,UAAU,GAAG,MAAM,WAAW;QAGrC,IAAI,IAAI,CAAC,SAAS,KAAK,OACrB,IAAI,CAAC,SAAS,GAAG,MAAM,eAAe;QAGxC,MAAM,UAAU,GAAG;QACnB,MAAM,WAAW,GAAG;QACpB,MAAM,eAAe,GAAG;QACxB,MAAM,KAAK,GAAG;QAEd,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC;QAC9B,IAAI,CAAC,aAAa,CAAC,cAAc;QACjC,IAAI,CAAC,aAAa,CAAC,WAAW;IAChC;IAEA,mBAAmB,CAAC;IACpB,sBAAsB,CAAC;IA3KvB,YAAY,aAA+B,CAAE;aAPrC,cAAqC;aACrC,aAAoC;aACpC,mBAA0C;aAC1C,eAAsC;aACtC,cAAkC;QAIxC,IAAI,CAAC,aAAa,GAAG;IACvB;AA0KF;AAMO,MAAM,kDAAuB;IAelC,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,IAAI,MAAM,KAAK,EAAE;QACf,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,IAAI;IACnC;IAEA,IAAI,QAAgB;QAClB,IAAI,IAAI,CAAC,UAAU,YAAY,2CAC7B,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,GAAI,CAAA,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,CAAA;QAGlE,OAAO;IACT;IAEA,aAAa;YAKI,uBACA,mBAEM,kBACD;QARpB,IAAI,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI;QACjD,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,KAAK,GAAG,IAAI,CAAC,KAAK;QACvB,KAAK,SAAS,GAAG,IAAI,CAAC,UAAU,YAAY,4CAAc,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,GAAG;YACtE;QAAf,KAAK,OAAO,GAAG,CAAA,kCAAA,wBAAA,IAAI,CAAC,eAAe,cAApB,4CAAA,sBAAsB,IAAI,CAAC,GAAG,cAA9B,4CAAA,iCAAkC;YAClC;QAAf,KAAK,OAAO,GAAG,CAAA,8BAAA,oBAAA,IAAI,CAAC,WAAW,cAAhB,wCAAA,kBAAkB,IAAI,CAAC,GAAG,cAA1B,wCAAA,6BAA8B;QAC7C,KAAK,aAAa,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU;YACjB;QAArB,KAAK,aAAa,GAAG,CAAA,6BAAA,mBAAA,IAAI,CAAC,UAAU,cAAf,uCAAA,iBAAiB,IAAI,CAAC,GAAG,cAAzB,uCAAA,4BAA6B;YAC9B;QAApB,KAAK,YAAY,GAAG,CAAA,4BAAA,kBAAA,IAAI,CAAC,SAAS,cAAd,sCAAA,gBAAgB,IAAI,CAAC,GAAG,cAAxB,sCAAA,2BAA4B;IAClD;IAEA,SAA4B,GAAQ,EAAE,GAAoB,EAAE,QAAc,EAAE;QAC1E,IAAI,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI;QACjD,IAAI,SAAC,KAAK,aAAE,SAAS,MAAE,EAAE,EAAE,GAAG,OAAM,GAAG;QACvC,MAAM,GAAG,GAAG;QACZ,KAAK,KAAK,GAAG;QACb,KAAK,QAAQ,GAAG;QAChB,KAAK,KAAK,GAAG;QACb,KAAK,SAAS,GAAG,aAAc,CAAA,OAAO,aAAa,WAAW,WAAW,EAAC,KAAM,GAAG,CAAC,aAAa,IAAI;QACrG,IAAI,MAAM,QAAQ,OAAO,KAAK,GAAG,EAAE;YACjC,IAAI,IAAI,CAAC,WAAW,EAClB,MAAM,IAAI,MAAM;YAElB,KAAK,GAAG,GAAG;QACb;QAEA,gGAAgG;QAChG,+BAA+B;QAC/B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACrB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI;YAC/B,IAAI,CAAC,aAAa,CAAC,cAAc;YACjC,IAAI,CAAC,WAAW,GAAG;QACrB;QAEA,IAAI,CAAC,aAAa,CAAC,WAAW;IAChC;IAEA,IAAI,QAAQ;QACV,OAAO,CAAC;IACV;IAEA,eAAe,CAAC;IAChB,eAAe,CAAC;IAChB,iBAAiB,CAAC;IAClB,kBAAkB,CAAC;IAvEnB,YAAY,IAAY,EAAE,aAA+B,CAAE;QACzD,KAAK,CAAC;aANR,WAAW,EAAG,0FAA0F;;aAEhG,SAAiB;aACzB,cAAc;QAIZ,IAAI,CAAC,IAAI,GAAG,IAAI,0CAAU,MAAM,CAAC,WAAW,EAAE,EAAE,cAAc,MAAM,CAAC,CAAC;QACtE,yEAAyE;QACzE,2EAA2E;QAC3E,sFAAsF;QACtF,IAAI,CAAC,aAAa,CAAC,gBAAgB;IACrC;AAiEF;AAMO,MAAM;IAMX,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;IACzB;IAEA,UAAU;QACR,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;IACzB;IAEA,CAAC,CAAC,OAAO,QAAQ,CAAC,GAAG;QACnB,IAAI,OAA4B,IAAI,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,IAAI;QACzF,MAAO,KAAM;YACX,MAAM;YACN,OAAO,KAAK,OAAO,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,OAAO,IAAI;QAChE;IACF;IAEA,YAAY,GAAQ,EAAqB;QACvC,IAAI,SAAS,IAAI,CAAC,MAAM;QACxB,OAAO;YACL,CAAC,CAAC,OAAO,QAAQ,CAAC;gBAChB,IAAI,SAAS,OAAO,GAAG,CAAC;gBACxB,IAAI,OAAO,CAAA,mBAAA,6BAAA,OAAQ,aAAa,KAAI,OAAO,OAAO,GAAG,CAAC,OAAO,aAAa,IAAI;gBAC9E,MAAO,KAAM;oBACX,MAAM;oBACN,OAAO,KAAK,OAAO,IAAI,OAAO,OAAO,GAAG,CAAC,KAAK,OAAO,IAAI;gBAC3D;YACF;QACF;IACF;IAEA,aAAa,GAAQ,EAAE;QACrB,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC3B,IAAI,CAAC,MACH,OAAO;QAGT,IAAI,KAAK,OAAO,IAAI,MAAM;YACxB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,OAAO;YAEnC,MAAO,QAAQ,KAAK,IAAI,KAAK,UAAU,KAAK,YAAY,IAAI,KAC1D,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,YAAY;gBAGnC;YAAP,OAAO,CAAA,YAAA,iBAAA,2BAAA,KAAM,GAAG,cAAT,uBAAA,YAAa;QACtB;QAEA,OAAO,KAAK,SAAS;IACvB;IAEA,YAAY,GAAQ,EAAE;QACpB,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;QAC3B,IAAI,CAAC,MACH,OAAO;QAGT,IAAI,KAAK,IAAI,KAAK,UAAU,KAAK,aAAa,IAAI,MAChD,OAAO,KAAK,aAAa;QAG3B,MAAO,KAAM;YACX,IAAI,KAAK,OAAO,IAAI,MAClB,OAAO,KAAK,OAAO;YAGrB,IAAI,KAAK,SAAS,IAAI,MACpB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS;iBAErC,OAAO;QAEX;QAEA,OAAO;IACT;IAEA,cAAc;QACZ,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA,aAAa;QACX,IAAI,OAAO,IAAI,CAAC,OAAO,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI;QAClE,MAAO,CAAA,iBAAA,2BAAA,KAAM,YAAY,KAAI,KAC3B,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,YAAY;YAGnC;QAAP,OAAO,CAAA,YAAA,iBAAA,2BAAA,KAAM,GAAG,cAAT,uBAAA,YAAa;IACtB;IAEA,QAAQ,GAAQ,EAAkB;YACzB;QAAP,OAAO,CAAA,mBAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAhB,8BAAA,mBAAwB;IACjC;IAEA,KAAc;QACZ,MAAM,IAAI,MAAM;IAClB;IAEA,QAAc;QACZ,uFAAuF;QACvF,yCAAyC;QACzC,sDAAsD;QACtD,IAAI,cAAmB,IAAI,CAAC,WAAW;QACvC,IAAI,aAAmB,IAAI;QAC3B,WAAW,MAAM,GAAG,IAAI,IAAI,IAAI,CAAC,MAAM;QACvC,WAAW,QAAQ,GAAG,IAAI,CAAC,QAAQ;QACnC,WAAW,OAAO,GAAG,IAAI,CAAC,OAAO;QACjC,OAAO;IACT;IAEA,QAAQ,IAAkB,EAAE;QAC1B,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,EAAE;IAC5B;IAEA,WAAW,GAAQ,EAAE;QACnB,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;IACrB;IAEA,OAAO,QAAoB,EAAE,OAAmB,EAAE,QAAQ,KAAK,EAAE;QAC/D,IAAI,IAAI,CAAC,MAAM,EACb,MAAM,IAAI,MAAM;QAGlB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,MAAM,GAAG,CAAC;IACjB;;aAxIQ,SAAiC,IAAI;aACrC,WAAuB;aACvB,UAAsB;aACtB,SAAS;;AAsInB;AAMO,MAAM,kDAAqE;IAoBhF,IAAI,cAAc;QAChB,OAAO;IACT;IAEA,cAAc,IAAY,EAAE;QAC1B,OAAO,IAAI,0CAAY,MAAM,IAAI;IACnC;IAEA;;;GAGC,GACD,eAAe,OAAuB,EAAyB;QAC7D,IAAI,OAAO,QAAQ,IAAI;QACvB,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,UAAU;YACnC,OAAO,QAAQ,IAAI,CAAC,KAAK;YACzB,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC;YACtB,QAAQ,IAAI,GAAG;QACjB;QACA,IAAI,CAAC,SAAS,CAAC;QACf,OAAO;IACT;IAEQ,uBAAuB;QAC7B,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC1C,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK;YACvC,IAAI,CAAC,iBAAiB,GAAG;QAC3B;QAEA,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA,UAAU,IAAiB,EAAE;QAC3B,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC;IACtB;IAEA,mBAAmB;QACjB,IAAI,CAAC,gBAAgB;IACvB;IAEA,iBAAiB;QACf,IAAI,CAAC,gBAAgB;IACvB;IAEA,QAAQ,OAAuB,EAAE;QAC/B,IAAI,aAAa,IAAI,CAAC,oBAAoB;QAC1C,IAAI,CAAC,WAAW,OAAO,CAAC,QAAQ,IAAI,CAAC,GAAG,GAAG;YACzC,WAAW,OAAO,CAAC,QAAQ,IAAI;YAE/B,KAAK,IAAI,SAAS,QAChB,IAAI,CAAC,OAAO,CAAC;QAEjB;QAEA,IAAI,CAAC,SAAS,CAAC;IACjB;IAEA,WAAW,IAAoB,EAAE;QAC/B,KAAK,IAAI,SAAS,KAChB,IAAI,CAAC,UAAU,CAAC;QAGlB,IAAI,aAAa,IAAI,CAAC,oBAAoB;QAC1C,WAAW,UAAU,CAAC,KAAK,IAAI,CAAC,GAAG;QACnC,IAAI,CAAC,SAAS,CAAC;IACjB;IAEA,qFAAqF,GACrF,gBAAmB;QACjB,IAAI,IAAI,CAAC,gBAAgB,GAAG,GAC1B,OAAO,IAAI,CAAC,UAAU;QAGxB,IAAI,CAAC,gBAAgB;QACrB,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA,mBAAmB;QACjB,KAAK,IAAI,WAAW,IAAI,CAAC,UAAU,CACjC,IAAI,mBAAmB,6CAAe,QAAQ,WAAW,EACvD,QAAQ,UAAU;QAItB,IAAI,CAAC,UAAU,CAAC,KAAK;QAErB,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,EAAE;gBAQlC,kBAAmC;YAPrD,IAAI,aAAa,IAAI,CAAC,oBAAoB;YAC1C,KAAK,IAAI,WAAW,IAAI,CAAC,YAAY,CACnC,IAAI,QAAQ,WAAW,EACrB,WAAW,OAAO,CAAC,QAAQ,IAAI;gBAIjB,2BAAmC;YAArD,WAAW,MAAM,CAAC,CAAA,6BAAA,mBAAA,IAAI,CAAC,UAAU,cAAf,uCAAA,iBAAiB,IAAI,CAAC,GAAG,cAAzB,uCAAA,4BAA6B,MAAM,CAAA,4BAAA,kBAAA,IAAI,CAAC,SAAS,cAAd,sCAAA,gBAAgB,IAAI,CAAC,GAAG,cAAxB,sCAAA,2BAA4B,MAAM,IAAI,CAAC,KAAK;YACjG,IAAI,CAAC,YAAY,CAAC,KAAK;QACzB;QAEA,IAAI,CAAC,iBAAiB,GAAG;IAC3B;IAEA,cAAc;QACZ,gEAAgE;QAChE,4DAA4D;QAC5D,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,KAAK,KAAK,IAAI,CAAC,gBAAgB,GAAG,GACxD;QAGF,KAAK,IAAI,MAAM,IAAI,CAAC,aAAa,CAC/B;IAEJ;IAEA,UAAU,EAAc,EAAE;QACxB,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;QACvB,OAAO,IAAM,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC;IACzC;IAEA,gBAAgB;QACd,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,IAAI,CAAC,KAAK,GAAG;YACb,IAAI,CAAC,UAAU,GAAG;YAClB,IAAI,CAAC,SAAS,GAAG;YACjB,IAAI,CAAC,MAAM,GAAG;QAChB;IACF;IApIA,YAAY,UAAa,CAAE;QACzB,aAAa;QACb,KAAK,CAAC;aAdR,WAAW,GAAI,yBAAyB;;aACxC,gBAAgB,IAAI;aACpB,aAA+B,IAAI;aACnC,QAAQ;aACR,SAAS;aACT,eAAe,IAAI;aAGX,eAAoC,IAAI;aACxC,gBAAiC,IAAI;aACrC,mBAAmB;QAKzB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,iBAAiB,GAAG;IAC3B;AAgIF;AAeO,SAAS,0CAAoC,KAA+B;IACjF,IAAI,YAAC,QAAQ,SAAE,KAAK,WAAE,OAAO,iBAAE,aAAa,gBAAE,eAAe,EAAE,EAAC,GAAG;IAEnE,0DAA0D;IAC1D,uDAAuD;IACvD,IAAI,QAAQ,CAAA,GAAA,oBAAM,EAAE,IAAM,IAAI,WAAW;IACzC,OAAO,CAAA,GAAA,oBAAM,EAAE;QACb,IAAI,SAAS,OAAO,aAAa,YAAY;YAC3C,IAAI,MAAsB,EAAE;YAC5B,KAAK,IAAI,QAAQ,MAAO;gBACtB,IAAI,WAAW,MAAM,GAAG,CAAC;gBACzB,IAAI,CAAC,UAAU;oBACb,WAAW,SAAS;wBAEV,oBAAA;oBADV,aAAa;oBACb,IAAI,MAAM,CAAA,OAAA,CAAA,qBAAA,SAAS,KAAK,CAAC,EAAE,cAAjB,gCAAA,qBAAqB,KAAK,GAAG,cAA7B,kBAAA,OAAiC,KAAK,EAAE;oBAClD,qCAAqC;oBACrC,IAAI,OAAO,MACT,MAAM,IAAI,MAAM;oBAElB,qCAAqC;oBACrC,IAAI,SACF,MAAM,UAAU,MAAM;oBAExB,wDAAwD;oBACxD,yBAAW,CAAA,GAAA,yBAAW,EACpB,UACA,gBAAgB;6BAAC;wBAAK,IAAI;wBAAK,OAAO;oBAAI,IAAI;6BAAC;oBAAG;oBAEpD,MAAM,GAAG,CAAC,MAAM;gBAClB;gBACA,IAAI,IAAI,CAAC;YACX;YACA,OAAO;QACT,OAAO,IAAI,OAAO,aAAa,YAC7B,OAAO;IAEX,GAAG;QAAC;QAAU;QAAO;QAAO;QAAS;KAAc;AACrD;AAEO,SAAS,0CAAwC,KAA+B;IACrF,OAAO,0CAAkB;QAAC,GAAG,KAAK;QAAE,eAAe;IAAI;AACzD;AAEA,MAAM,2DAAuB,CAAA,GAAA,0BAAY,EAAE;AAOpC,SAAS,0CAA6D,KAAyB,EAAE,iBAAqB;IAC3H,IAAI,cAAC,UAAU,YAAE,QAAQ,EAAC,GAAG,0CAA4B;IACzD,IAAI,SAAS,0CAA0B,OAAO;IAC9C,OAAO;gBAAC;oBAAQ;IAAU;AAC5B;AAOA,kIAAkI;AAClI,8GAA8G;AAC9G,SAAS,mDAAgC,SAAoD,EAAE,WAAoB,EAAE,iBAA0B;IAC7I,IAAI,QAAQ,CAAA,GAAA,yBAAO;IACnB,IAAI,WAAW,CAAA,GAAA,mBAAK,EAAE;IACtB,8EAA8E;IAC9E,sEAAsE;IACtE,gEAAgE;IAChE,gDAAgD;IAChD,SAAS,OAAO,GAAG;IAEnB,IAAI,qBAAqB,CAAA,GAAA,wBAAU,EAAE;QACnC,OAAO,SAAS,OAAO,GAAG,sBAAsB;IAClD,GAAG;QAAC;QAAa;KAAkB;IACnC,OAAO,CAAA,GAAA,2DAAuB,EAAE,WAAW;AAC7C;AAEA,MAAM,6CAAuB,OAAO,CAAA,GAAA,sCAAI,CAAC,CAAC,uBAAuB,KAAK,aAClE,CAAA,GAAA,sCAAI,CAAC,CAAC,uBAAuB,GAC7B;AAEG,SAAS,0CAAqE,iBAAqB;IACxG,6EAA6E;IAC7E,kGAAkG;IAClG,IAAI,WAAW,CAAA,GAAA,oBAAM,EAAE,IAAM,IAAI,0CAAe,qBAAqB,IAAI,8CAAwB;QAAC;KAAkB;IACpH,IAAI,YAAY,CAAA,GAAA,wBAAU,EAAE,CAAC,KAAmB,SAAS,SAAS,CAAC,KAAK;QAAC;KAAS;IAClF,IAAI,cAAc,CAAA,GAAA,wBAAU,EAAE;QAC5B,IAAI,aAAa,SAAS,aAAa;QACvC,IAAI,SAAS,KAAK,EAChB,yGAAyG;QACzG,0GAA0G;QAC1G,0EAA0E;QAC1E,SAAS,aAAa;QAExB,OAAO;IACT,GAAG;QAAC;KAAS;IACb,IAAI,oBAAoB,CAAA,GAAA,wBAAU,EAAE;QAClC,SAAS,KAAK,GAAG;QACjB,OAAO,SAAS,aAAa;IAC/B,GAAG;QAAC;KAAS;IACb,IAAI,aAAa,2CAAqB,WAAW,aAAa;IAC9D,OAAO;oBAAC;kBAAY;IAAQ;AAC9B;AAEA,MAAM,iDAAa,CAAA,GAAA,0BAAY,EAAwB;AAChD,MAAM,0DAA4B,CAAA,GAAA,0BAAY,EAA6C;AAE3F,SAAS,0CAAmE,KAAyB,EAAE,QAAyB;IACrI,IAAI,MAAM,CAAA,GAAA,uBAAS,EAAE;IACrB,IAAI,MAAM,qBAAA,sBAAA,WAAY;IACtB,IAAI,WAAW,0CAAsB;IACrC,IAAI,kBAAkB,CAAA,GAAA,oBAAM,EAAE,kBAC5B,0DAAC,2CAAqB,QAAQ;YAAC,OAAA;WAC5B,WAEF;QAAC;KAAS;IACb,8FAA8F;IAC9F,0FAA0F;IAC1F,OAAO,CAAA,GAAA,yBAAO,oBACV,0DAAC,iCAAW,QAAQ;QAAC,OAAO;OAAM,iCAClC,CAAA,GAAA,4BAAW,EAAE,iBAAiB;AACpC;AAEO,SAAS,yCAAmC,KAAyB;IAC1E,qBAAO,sHAAG,0CAAoB;AAChC;AAGO,SAAS,0CAAsD,IAAY,EAAE,KAAQ,EAAE,GAAoB;IAChH,IAAI,YAAY,CAAA,GAAA,uBAAS,EAAE;QAIlB;IAHT,IAAI,WACF,uEAAuE;IACvE,sDAAsD;IACtD,OAAO,CAAA,wBAAA,0CAAqB,MAAM,OAAO,KAAK,cAAc,QAAQ,MAAM,QAAQ,GAAG,mBAA9E,mCAAA,sCAAuF;IAGhG,OAAO;AACT;AA6DO,SAAS,0CAAwC,KAAU,EAAE,GAAoB,EAAE,QAAc;IACtG,yEAAyE;IACzE,OAAO,CAAA,GAAA,wBAAU,EAAE,CAAC;QAClB,oBAAA,8BAAA,QAAS,QAAQ,CAAC,OAAO,KAAK;IAChC,GAAG;QAAC;QAAO;QAAK;KAAS;AAC3B;AAEO,SAAS,0CAAwC,IAAY,EAAE,KAAa,EAAE,GAAoB,EAAE,QAAc,EAAE,QAAoB;IAC7I,sGAAsG;IACtG,qGAAqG;IACrG,oGAAoG;IACpG,kFAAkF;IAClF,mEAAmE;IACnE,IAAI,UAAU,0CAAqB,OAAO,KAAK;IAC/C,IAAI,aAAa,CAAA,GAAA,uBAAS,EAAE;IAC5B,IAAI,YAAY;QACd,iDAAiD;QACjD,IAAI,UAAU,WAAW,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC;QACxD,IAAI,CAAC,SAAS;YACZ,UAAU,WAAW,aAAa,CAAC,aAAa,CAAC;YACjD,QAAQ,QAAQ,CAAC,OAAO,KAAK;YAC7B,WAAW,WAAW,CAAC;YACvB,WAAW,aAAa,CAAC,gBAAgB;YACzC,WAAW,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO;QACnD;QAEA,OAAO,yBACH,0DAAC,iCAAW,QAAQ;YAAC,OAAO;WAAU,YACtC;IACN;IAEA,aAAa;IACb,qBAAO,0DAAC;QAAK,KAAK;OAAU;AAC9B;AAaA,SAAS,8BAA0B,KAAsB,EAAE,GAA8B;IACvF,IAAI,WAAW,0CAAsB;IACrC,OAAO,0CAAqB,WAAW,OAAO,KAAK,MAAM;AAC3D;AAEA,MAAM,4CAAyB,AAAd,WAAW,GAAI,CAAA,GAAA,uBAAS,EAAqB;AAGvD,MAAM,0DAAoB,CAAA,GAAA,0BAAY,EAAyC;AAC/E,MAAM,0DAA4B,CAAA,GAAA,0BAAY,EAAoC;AAGlF,SAAS,0CAA6B,KAAyB;IACpE,IAAI,MAAM,CAAA,GAAA,uBAAS,EAAE;IACrB,QAAQ,CAAA,GAAA,2BAAS,EAAE,KAAK;IACxB,MAAM,YAAY,GAAG,AAAC,CAAA,CAAA,gBAAA,0BAAA,IAAK,YAAY,KAAI,EAAE,AAAD,EAAG,MAAM,CAAC,MAAM,YAAY;IACxE,IAAI,WAAW,OAAO,MAAM,QAAQ,KAAK,aAAa,MAAM,QAAQ,GAAG;IACvE,qBACE,0DAAC,0CAA0B,QAAQ;QAAC,OAAO;OACxC,0CAAsB;AAG7B","sources":["packages/react-aria-components/src/Collection.tsx"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {CollectionBase, Key} from '@react-types/shared';\nimport {createPortal} from 'react-dom';\nimport {forwardRefType, StyleProps} from './utils';\nimport {Collection as ICollection, Node, SelectionBehavior, SelectionMode, SectionProps as SharedSectionProps} from 'react-stately';\nimport {mergeProps, useIsSSR} from 'react-aria';\nimport React, {cloneElement, createContext, ForwardedRef, forwardRef, JSX, ReactElement, ReactNode, useCallback, useContext, useMemo, useRef} from 'react';\nimport {useSyncExternalStore as useSyncExternalStoreShim} from 'use-sync-external-store/shim/index.js';\n\n// This Collection implementation is perhaps a little unusual. It works by rendering the React tree into a\n// Portal to a fake DOM implementation. This gives us efficient access to the tree of rendered objects, and\n// supports React features like composition and context. We use this fake DOM to access the full set of elements\n// before we render into the real DOM, which allows us to render a subset of the elements (e.g. virtualized scrolling),\n// and compute properties like the total number of items. It also enables keyboard navigation, selection, and other features.\n// React takes care of efficiently rendering components and updating the collection for us via this fake DOM.\n//\n// The DOM is a mutable API, and React expects the node instances to remain stable over time. So the implementation is split\n// into two parts. Each mutable fake DOM node owns an instance of an immutable collection node. When a fake DOM node is updated,\n// it queues a second render for the collection. Multiple updates to a collection can be queued at once. Collection nodes are\n// lazily copied on write, so only the changed nodes need to be cloned. During the second render, the new immutable collection\n// is finalized by updating the map of Key -> Node with the new cloned nodes. Then the new collection is frozen so it can no\n// longer be mutated, and returned to the calling component to render.\n\ntype Mutable<T> = {\n  -readonly[P in keyof T]: T[P]\n}\n\n/** An immutable object representing a Node in a Collection. */\nexport class NodeValue<T> implements Node<T> {\n  readonly type: string;\n  readonly key: Key;\n  readonly value: T | null = null;\n  readonly level: number = 0;\n  readonly hasChildNodes: boolean = false;\n  readonly rendered: ReactNode = null;\n  readonly textValue: string = '';\n  readonly 'aria-label'?: string = undefined;\n  readonly index: number = 0;\n  readonly parentKey: Key | null = null;\n  readonly prevKey: Key | null = null;\n  readonly nextKey: Key | null = null;\n  readonly firstChildKey: Key | null = null;\n  readonly lastChildKey: Key | null = null;\n  readonly props: any = {};\n\n  constructor(type: string, key: Key) {\n    this.type = type;\n    this.key = key;\n  }\n\n  get childNodes(): Iterable<Node<T>> {\n    throw new Error('childNodes is not supported');\n  }\n\n  clone(): NodeValue<T> {\n    let node: Mutable<NodeValue<T>> = new NodeValue(this.type, this.key);\n    node.value = this.value;\n    node.level = this.level;\n    node.hasChildNodes = this.hasChildNodes;\n    node.rendered = this.rendered;\n    node.textValue = this.textValue;\n    node['aria-label'] = this['aria-label'];\n    node.index = this.index;\n    node.parentKey = this.parentKey;\n    node.prevKey = this.prevKey;\n    node.nextKey = this.nextKey;\n    node.firstChildKey = this.firstChildKey;\n    node.lastChildKey = this.lastChildKey;\n    node.props = this.props;\n    return node;\n  }\n}\n\n/**\n * A mutable node in the fake DOM tree. When mutated, it marks itself as dirty\n * and queues an update with the owner document.\n */\nclass BaseNode<T> {\n  private _firstChild: ElementNode<T> | null = null;\n  private _lastChild: ElementNode<T> | null = null;\n  private _previousSibling: ElementNode<T> | null = null;\n  private _nextSibling: ElementNode<T> | null = null;\n  private _parentNode: BaseNode<T> | null = null;\n  ownerDocument: Document<T, any>;\n\n  constructor(ownerDocument: Document<T, any>) {\n    this.ownerDocument = ownerDocument;\n  }\n\n  *[Symbol.iterator]() {\n    let node = this.firstChild;\n    while (node) {\n      yield node;\n      node = node.nextSibling;\n    }\n  }\n\n  get firstChild() {\n    return this._firstChild;\n  }\n\n  set firstChild(firstChild) {\n    this._firstChild = firstChild;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get lastChild() {\n    return this._lastChild;\n  }\n\n  set lastChild(lastChild) {\n    this._lastChild = lastChild;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get previousSibling() {\n    return this._previousSibling;\n  }\n\n  set previousSibling(previousSibling) {\n    this._previousSibling = previousSibling;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get nextSibling() {\n    return this._nextSibling;\n  }\n\n  set nextSibling(nextSibling) {\n    this._nextSibling = nextSibling;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get parentNode() {\n    return this._parentNode;\n  }\n\n  set parentNode(parentNode) {\n    this._parentNode = parentNode;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get isConnected() {\n    return this.parentNode?.isConnected || false;\n  }\n\n  appendChild(child: ElementNode<T>) {\n    this.ownerDocument.startTransaction();\n    if (child.parentNode) {\n      child.parentNode.removeChild(child);\n    }\n\n    if (this.firstChild == null) {\n      this.firstChild = child;\n    }\n\n    if (this.lastChild) {\n      this.lastChild.nextSibling = child;\n      child.index = this.lastChild.index + 1;\n      child.previousSibling = this.lastChild;\n    } else {\n      child.previousSibling = null;\n      child.index = 0;\n    }\n\n    child.parentNode = this;\n    child.nextSibling = null;\n    this.lastChild = child;\n\n    this.ownerDocument.markDirty(this);\n    if (child.hasSetProps) {\n      // Only add the node to the collection if we already received props for it.\n      // Otherwise wait until then so we have the correct id for the node.\n      this.ownerDocument.addNode(child);\n    }\n\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  insertBefore(newNode: ElementNode<T>, referenceNode: ElementNode<T>) {\n    if (referenceNode == null) {\n      return this.appendChild(newNode);\n    }\n\n    this.ownerDocument.startTransaction();\n    if (newNode.parentNode) {\n      newNode.parentNode.removeChild(newNode);\n    }\n\n    newNode.nextSibling = referenceNode;\n    newNode.previousSibling = referenceNode.previousSibling;\n    newNode.index = referenceNode.index;\n\n    if (this.firstChild === referenceNode) {\n      this.firstChild = newNode;\n    } else if (referenceNode.previousSibling) {\n      referenceNode.previousSibling.nextSibling = newNode;\n    }\n\n    referenceNode.previousSibling = newNode;\n    newNode.parentNode = referenceNode.parentNode;\n\n    let node: ElementNode<T> | null = referenceNode;\n    while (node) {\n      node.index++;\n      node = node.nextSibling;\n    }\n\n    if (newNode.hasSetProps) {\n      this.ownerDocument.addNode(newNode);\n    }\n\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  removeChild(child: ElementNode<T>) {\n    if (child.parentNode !== this) {\n      return;\n    }\n\n    this.ownerDocument.startTransaction();\n    let node = child.nextSibling;\n    while (node) {\n      node.index--;\n      node = node.nextSibling;\n    }\n\n    if (child.nextSibling) {\n      child.nextSibling.previousSibling = child.previousSibling;\n    }\n\n    if (child.previousSibling) {\n      child.previousSibling.nextSibling = child.nextSibling;\n    }\n\n    if (this.firstChild === child) {\n      this.firstChild = child.nextSibling;\n    }\n\n    if (this.lastChild === child) {\n      this.lastChild = child.previousSibling;\n    }\n\n    child.parentNode = null;\n    child.nextSibling = null;\n    child.previousSibling = null;\n    child.index = 0;\n\n    this.ownerDocument.removeNode(child);\n    this.ownerDocument.endTransaction();\n    this.ownerDocument.queueUpdate();\n  }\n\n  addEventListener() {}\n  removeEventListener() {}\n}\n\n/**\n * A mutable element node in the fake DOM tree. It owns an immutable\n * Collection Node which is copied on write.\n */\nexport class ElementNode<T> extends BaseNode<T> {\n  nodeType = 8; // COMMENT_NODE (we'd use ELEMENT_NODE but React DevTools will fail to get its dimensions)\n  node: NodeValue<T>;\n  private _index: number = 0;\n  hasSetProps = false;\n\n  constructor(type: string, ownerDocument: Document<T, any>) {\n    super(ownerDocument);\n    this.node = new NodeValue(type, `react-aria-${++ownerDocument.nodeId}`);\n    // Start a transaction so that no updates are emitted from the collection\n    // until the props for this node are set. We don't know the real id for the\n    // node until then, so we need to avoid emitting collections in an inconsistent state.\n    this.ownerDocument.startTransaction();\n  }\n\n  get index() {\n    return this._index;\n  }\n\n  set index(index) {\n    this._index = index;\n    this.ownerDocument.markDirty(this);\n  }\n\n  get level(): number {\n    if (this.parentNode instanceof ElementNode) {\n      return this.parentNode.level + (this.node.type === 'item' ? 1 : 0);\n    }\n\n    return 0;\n  }\n\n  updateNode() {\n    let node = this.ownerDocument.getMutableNode(this);\n    node.index = this.index;\n    node.level = this.level;\n    node.parentKey = this.parentNode instanceof ElementNode ? this.parentNode.node.key : null;\n    node.prevKey = this.previousSibling?.node.key ?? null;\n    node.nextKey = this.nextSibling?.node.key ?? null;\n    node.hasChildNodes = !!this.firstChild;\n    node.firstChildKey = this.firstChild?.node.key ?? null;\n    node.lastChildKey = this.lastChild?.node.key ?? null;\n  }\n\n  setProps<T extends Element>(obj: any, ref: ForwardedRef<T>, rendered?: any) {\n    let node = this.ownerDocument.getMutableNode(this);\n    let {value, textValue, id, ...props} = obj;\n    props.ref = ref;\n    node.props = props;\n    node.rendered = rendered;\n    node.value = value;\n    node.textValue = textValue || (typeof rendered === 'string' ? rendered : '') || obj['aria-label'] || '';\n    if (id != null && id !== node.key) {\n      if (this.hasSetProps) {\n        throw new Error('Cannot change the id of an item');\n      }\n      node.key = id;\n    }\n\n    // If this is the first time props have been set, end the transaction started in the constructor\n    // so this node can be emitted.\n    if (!this.hasSetProps) {\n      this.ownerDocument.addNode(this);\n      this.ownerDocument.endTransaction();\n      this.hasSetProps = true;\n    }\n\n    this.ownerDocument.queueUpdate();\n  }\n\n  get style() {\n    return {};\n  }\n\n  hasAttribute() {}\n  setAttribute() {}\n  setAttributeNS() {}\n  removeAttribute() {}\n}\n\n/**\n * An immutable Collection implementation. Updates are only allowed\n * when it is not marked as frozen.\n */\nexport class BaseCollection<T> implements ICollection<Node<T>> {\n  private keyMap: Map<Key, NodeValue<T>> = new Map();\n  private firstKey: Key | null = null;\n  private lastKey: Key | null = null;\n  private frozen = false;\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  getKeys() {\n    return this.keyMap.keys();\n  }\n\n  *[Symbol.iterator]() {\n    let node: Node<T> | undefined = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;\n    while (node) {\n      yield node;\n      node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;\n    }\n  }\n\n  getChildren(key: Key): Iterable<Node<T>> {\n    let keyMap = this.keyMap;\n    return {\n      *[Symbol.iterator]() {\n        let parent = keyMap.get(key);\n        let node = parent?.firstChildKey != null ? keyMap.get(parent.firstChildKey) : null;\n        while (node) {\n          yield node as Node<T>;\n          node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;\n        }\n      }\n    };\n  }\n\n  getKeyBefore(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.prevKey != null) {\n      node = this.keyMap.get(node.prevKey);\n\n      while (node && node.type !== 'item' && node.lastChildKey != null) {\n        node = this.keyMap.get(node.lastChildKey);\n      }\n\n      return node?.key ?? null;\n    }\n\n    return node.parentKey;\n  }\n\n  getKeyAfter(key: Key) {\n    let node = this.keyMap.get(key);\n    if (!node) {\n      return null;\n    }\n\n    if (node.type !== 'item' && node.firstChildKey != null) {\n      return node.firstChildKey;\n    }\n\n    while (node) {\n      if (node.nextKey != null) {\n        return node.nextKey;\n      }\n\n      if (node.parentKey != null) {\n        node = this.keyMap.get(node.parentKey);\n      } else {\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  getFirstKey() {\n    return this.firstKey;\n  }\n\n  getLastKey() {\n    let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;\n    while (node?.lastChildKey != null) {\n      node = this.keyMap.get(node.lastChildKey);\n    }\n\n    return node?.key ?? null;\n  }\n\n  getItem(key: Key): Node<T> | null {\n    return this.keyMap.get(key) ?? null;\n  }\n\n  at(): Node<T> {\n    throw new Error('Not implemented');\n  }\n\n  clone(): this {\n    // We need to clone using this.constructor so that subclasses have the right prototype.\n    // TypeScript isn't happy about this yet.\n    // https://github.com/microsoft/TypeScript/issues/3841\n    let Constructor: any = this.constructor;\n    let collection: this = new Constructor();\n    collection.keyMap = new Map(this.keyMap);\n    collection.firstKey = this.firstKey;\n    collection.lastKey = this.lastKey;\n    return collection;\n  }\n\n  addNode(node: NodeValue<T>) {\n    if (this.frozen) {\n      throw new Error('Cannot add a node to a frozen collection');\n    }\n\n    this.keyMap.set(node.key, node);\n  }\n\n  removeNode(key: Key) {\n    if (this.frozen) {\n      throw new Error('Cannot remove a node to a frozen collection');\n    }\n\n    this.keyMap.delete(key);\n  }\n\n  commit(firstKey: Key | null, lastKey: Key | null, isSSR = false) {\n    if (this.frozen) {\n      throw new Error('Cannot commit a frozen collection');\n    }\n\n    this.firstKey = firstKey;\n    this.lastKey = lastKey;\n    this.frozen = !isSSR;\n  }\n}\n\n/**\n * A mutable Document in the fake DOM. It owns an immutable Collection instance,\n * which is lazily copied on write during updates.\n */\nexport class Document<T, C extends BaseCollection<T> = BaseCollection<T>> extends BaseNode<T> {\n  nodeType = 11; // DOCUMENT_FRAGMENT_NODE\n  ownerDocument = this;\n  dirtyNodes: Set<BaseNode<T>> = new Set();\n  isSSR = false;\n  nodeId = 0;\n  nodesByProps = new WeakMap<object, ElementNode<T>>();\n  private collection: C;\n  private collectionMutated: boolean;\n  private mutatedNodes: Set<ElementNode<T>> = new Set();\n  private subscriptions: Set<() => void> = new Set();\n  private transactionCount = 0;\n\n  constructor(collection: C) {\n    // @ts-ignore\n    super(null);\n    this.collection = collection;\n    this.collectionMutated = true;\n  }\n\n  get isConnected() {\n    return true;\n  }\n\n  createElement(type: string) {\n    return new ElementNode(type, this);\n  }\n\n  /**\n   * Lazily gets a mutable instance of a Node. If the node has already\n   * been cloned during this update cycle, it just returns the existing one.\n   */\n  getMutableNode(element: ElementNode<T>): Mutable<NodeValue<T>> {\n    let node = element.node;\n    if (!this.mutatedNodes.has(element)) {\n      node = element.node.clone();\n      this.mutatedNodes.add(element);\n      element.node = node;\n    }\n    this.markDirty(element);\n    return node;\n  }\n\n  private getMutableCollection() {\n    if (!this.isSSR && !this.collectionMutated) {\n      this.collection = this.collection.clone();\n      this.collectionMutated = true;\n    }\n\n    return this.collection;\n  }\n\n  markDirty(node: BaseNode<T>) {\n    this.dirtyNodes.add(node);\n  }\n\n  startTransaction() {\n    this.transactionCount++;\n  }\n\n  endTransaction() {\n    this.transactionCount--;\n  }\n\n  addNode(element: ElementNode<T>) {\n    let collection = this.getMutableCollection();\n    if (!collection.getItem(element.node.key)) {\n      collection.addNode(element.node);\n\n      for (let child of element) {\n        this.addNode(child);\n      }\n    }\n\n    this.markDirty(element);\n  }\n\n  removeNode(node: ElementNode<T>) {\n    for (let child of node) {\n      this.removeNode(child);\n    }\n\n    let collection = this.getMutableCollection();\n    collection.removeNode(node.node.key);\n    this.markDirty(node);\n  }\n\n  /** Finalizes the collection update, updating all nodes and freezing the collection. */\n  getCollection(): C {\n    if (this.transactionCount > 0) {\n      return this.collection;\n    }\n\n    this.updateCollection();\n    return this.collection;\n  }\n\n  updateCollection() {\n    for (let element of this.dirtyNodes) {\n      if (element instanceof ElementNode && element.isConnected) {\n        element.updateNode();\n      }\n    }\n\n    this.dirtyNodes.clear();\n\n    if (this.mutatedNodes.size || this.collectionMutated) {\n      let collection = this.getMutableCollection();\n      for (let element of this.mutatedNodes) {\n        if (element.isConnected) {\n          collection.addNode(element.node);\n        }\n      }\n\n      collection.commit(this.firstChild?.node.key ?? null, this.lastChild?.node.key ?? null, this.isSSR);\n      this.mutatedNodes.clear();\n    }\n\n    this.collectionMutated = false;\n  }\n\n  queueUpdate() {\n    // Don't emit any updates if there is a transaction in progress.\n    // queueUpdate should be called again after the transaction.\n    if (this.dirtyNodes.size === 0 || this.transactionCount > 0) {\n      return;\n    }\n\n    for (let fn of this.subscriptions) {\n      fn();\n    }\n  }\n\n  subscribe(fn: () => void) {\n    this.subscriptions.add(fn);\n    return () => this.subscriptions.delete(fn);\n  }\n\n  resetAfterSSR() {\n    if (this.isSSR) {\n      this.isSSR = false;\n      this.firstChild = null;\n      this.lastChild = null;\n      this.nodeId = 0;\n    }\n  }\n}\n\nexport interface CollectionProps<T> extends Omit<CollectionBase<T>, 'children'> {\n  /** The contents of the collection. */\n  children?: ReactNode | ((item: T) => ReactNode),\n  /** Values that should invalidate the item cache when using dynamic collections. */\n  dependencies?: any[]\n}\n\ninterface CachedChildrenOptions<T> extends CollectionProps<T> {\n  idScope?: Key,\n  addIdAndValue?: boolean,\n  dependencies?: any[]\n}\n\nexport function useCachedChildren<T extends object>(props: CachedChildrenOptions<T>): ReactNode {\n  let {children, items, idScope, addIdAndValue, dependencies = []} = props;\n\n  // Invalidate the cache whenever the parent value changes.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  let cache = useMemo(() => new WeakMap(), dependencies);\n  return useMemo(() => {\n    if (items && typeof children === 'function') {\n      let res: ReactElement[] = [];\n      for (let item of items) {\n        let rendered = cache.get(item);\n        if (!rendered) {\n          rendered = children(item);\n          // @ts-ignore\n          let key = rendered.props.id ?? item.key ?? item.id;\n          // eslint-disable-next-line max-depth\n          if (key == null) {\n            throw new Error('Could not determine key for item');\n          }\n          // eslint-disable-next-line max-depth\n          if (idScope) {\n            key = idScope + ':' + key;\n          }\n          // Note: only works if wrapped Item passes through id...\n          rendered = cloneElement(\n            rendered,\n            addIdAndValue ? {key, id: key, value: item} : {key}\n          );\n          cache.set(item, rendered);\n        }\n        res.push(rendered);\n      }\n      return res;\n    } else if (typeof children !== 'function') {\n      return children;\n    }\n  }, [children, items, cache, idScope, addIdAndValue]);\n}\n\nexport function useCollectionChildren<T extends object>(props: CachedChildrenOptions<T>) {\n  return useCachedChildren({...props, addIdAndValue: true});\n}\n\nconst ShallowRenderContext = createContext(false);\n\ninterface CollectionResult<C> {\n  portal: ReactNode,\n  collection: C\n}\n\nexport function useCollection<T extends object, C extends BaseCollection<T>>(props: CollectionProps<T>, initialCollection?: C): CollectionResult<C> {\n  let {collection, document} = useCollectionDocument<T, C>(initialCollection);\n  let portal = useCollectionPortal<T, C>(props, document);\n  return {portal, collection};\n}\n\ninterface CollectionDocumentResult<T, C extends BaseCollection<T>> {\n  collection: C,\n  document: Document<T, C>\n}\n\n// React 16 and 17 don't support useSyncExternalStore natively, and the shim provided by React does not support getServerSnapshot.\n// This wrapper uses the shim, but additionally calls getServerSnapshot during SSR (according to SSRProvider).\nfunction useSyncExternalStoreFallback<C>(subscribe: (onStoreChange: () => void) => () => void, getSnapshot: () => C, getServerSnapshot: () => C): C {\n  let isSSR = useIsSSR();\n  let isSSRRef = useRef(isSSR);\n  // This is read immediately inside the wrapper, which also runs during render.\n  // We just need a ref to avoid invalidating the callback itself, which\n  // would cause React to re-run the callback more than necessary.\n  // eslint-disable-next-line rulesdir/pure-render\n  isSSRRef.current = isSSR;\n\n  let getSnapshotWrapper = useCallback(() => {\n    return isSSRRef.current ? getServerSnapshot() : getSnapshot();\n  }, [getSnapshot, getServerSnapshot]);\n  return useSyncExternalStoreShim(subscribe, getSnapshotWrapper);\n}\n\nconst useSyncExternalStore = typeof React['useSyncExternalStore'] === 'function'\n  ? React['useSyncExternalStore']\n  : useSyncExternalStoreFallback;\n\nexport function useCollectionDocument<T extends object, C extends BaseCollection<T>>(initialCollection?: C): CollectionDocumentResult<T, C> {\n  // The document instance is mutable, and should never change between renders.\n  // useSyncExternalStore is used to subscribe to updates, which vends immutable Collection objects.\n  let document = useMemo(() => new Document<T, C>(initialCollection || new BaseCollection() as C), [initialCollection]);\n  let subscribe = useCallback((fn: () => void) => document.subscribe(fn), [document]);\n  let getSnapshot = useCallback(() => {\n    let collection = document.getCollection();\n    if (document.isSSR) {\n      // After SSR is complete, reset the document to empty so it is ready for React to render the portal into.\n      // We do this _after_ getting the collection above so that the collection still has content in it from SSR\n      // during the current render, before React has finished the client render.\n      document.resetAfterSSR();\n    }\n    return collection;\n  }, [document]);\n  let getServerSnapshot = useCallback(() => {\n    document.isSSR = true;\n    return document.getCollection();\n  }, [document]);\n  let collection = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n  return {collection, document};\n}\n\nconst SSRContext = createContext<BaseNode<any> | null>(null);\nexport const CollectionDocumentContext = createContext<Document<any, BaseCollection<any>> | null>(null);\n\nexport function useCollectionPortal<T extends object, C extends BaseCollection<T>>(props: CollectionProps<T>, document?: Document<T, C>): ReactNode {\n  let ctx = useContext(CollectionDocumentContext);\n  let doc = document ?? ctx!;\n  let children = useCollectionChildren(props);\n  let wrappedChildren = useMemo(() => (\n    <ShallowRenderContext.Provider value>\n      {children}\n    </ShallowRenderContext.Provider>\n  ), [children]);\n  // During SSR, we render the content directly, and append nodes to the document during render.\n  // The collection children return null so that nothing is actually rendered into the HTML.\n  return useIsSSR()\n    ? <SSRContext.Provider value={doc}>{wrappedChildren}</SSRContext.Provider>\n    : createPortal(wrappedChildren, doc as unknown as Element);\n}\n\nexport function CollectionPortal<T extends object>(props: CollectionProps<T>) {\n  return <>{useCollectionPortal(props)}</>;\n}\n\n/** Renders a DOM element (e.g. separator or header) shallowly when inside a collection. */\nexport function useShallowRender<P extends object, T extends Element>(type: string, props: P, ref: ForwardedRef<T>): ReactElement | null {\n  let isShallow = useContext(ShallowRenderContext);\n  if (isShallow) {\n    // Elements cannot be re-parented, so the context will always be there.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useSSRCollectionNode(type, props, ref, 'children' in props ? props.children : null) ?? <></>;\n  }\n\n  return null;\n}\n\nexport interface ItemRenderProps {\n  /**\n   * Whether the item is currently hovered with a mouse.\n   * @selector [data-hovered]\n   */\n  isHovered: boolean,\n  /**\n   * Whether the item is currently in a pressed state.\n   * @selector [data-pressed]\n   */\n  isPressed: boolean,\n  /**\n   * Whether the item is currently selected.\n   * @selector [data-selected]\n   */\n  isSelected: boolean,\n  /**\n   * Whether the item is currently focused.\n   * @selector [data-focused]\n   */\n  isFocused: boolean,\n  /**\n   * Whether the item is currently keyboard focused.\n   * @selector [data-focus-visible]\n   */\n  isFocusVisible: boolean,\n  /**\n   * Whether the item is non-interactive, i.e. both selection and actions are disabled and the item may\n   * not be focused. Dependent on `disabledKeys` and `disabledBehavior`.\n   * @selector [data-disabled]\n   */\n  isDisabled: boolean,\n  /**\n   * The type of selection that is allowed in the collection.\n   * @selector [data-selection-mode=\"single | multiple\"]\n   */\n  selectionMode: SelectionMode,\n  /** The selection behavior for the collection. */\n  selectionBehavior: SelectionBehavior,\n  /**\n   * Whether the item allows dragging.\n   * @note This property is only available in collection components that support drag and drop.\n   * @selector [data-allows-dragging]\n   */\n  allowsDragging?: boolean,\n  /**\n   * Whether the item is currently being dragged.\n   * @note This property is only available in collection components that support drag and drop.\n   * @selector [data-dragging]\n   */\n  isDragging?: boolean,\n  /**\n   * Whether the item is currently an active drop target.\n   * @note This property is only available in collection components that support drag and drop.\n   * @selector [data-drop-target]\n   */\n  isDropTarget?: boolean\n}\n\nexport function useCollectionItemRef<T extends Element>(props: any, ref: ForwardedRef<T>, rendered?: any) {\n  // Return a callback ref that sets the props object on the fake DOM node.\n  return useCallback((element) => {\n    element?.setProps(props, ref, rendered);\n  }, [props, ref, rendered]);\n}\n\nexport function useSSRCollectionNode<T extends Element>(Type: string, props: object, ref: ForwardedRef<T>, rendered?: any, children?: ReactNode) {\n  // During SSR, portals are not supported, so the collection children will be wrapped in an SSRContext.\n  // Since SSR occurs only once, we assume that the elements are rendered in order and never re-render.\n  // Therefore we can create elements in our collection document during render so that they are in the\n  // collection by the time we need to use the collection to render to the real DOM.\n  // After hydration, we switch to client rendering using the portal.\n  let itemRef = useCollectionItemRef(props, ref, rendered);\n  let parentNode = useContext(SSRContext);\n  if (parentNode) {\n    // Guard against double rendering in strict mode.\n    let element = parentNode.ownerDocument.nodesByProps.get(props);\n    if (!element) {\n      element = parentNode.ownerDocument.createElement(Type);\n      element.setProps(props, ref, rendered);\n      parentNode.appendChild(element);\n      parentNode.ownerDocument.updateCollection();\n      parentNode.ownerDocument.nodesByProps.set(props, element);\n    }\n\n    return children\n      ? <SSRContext.Provider value={element}>{children}</SSRContext.Provider>\n      : null;\n  }\n\n  // @ts-ignore\n  return <Type ref={itemRef}>{children}</Type>;\n}\n\nexport interface SectionProps<T> extends Omit<SharedSectionProps<T>, 'children' | 'title'>, StyleProps {\n  /** The unique id of the section. */\n  id?: Key,\n  /** The object value that this section represents. When using dynamic collections, this is set automatically. */\n  value?: T,\n  /** Static child items or a function to render children. */\n  children?: ReactNode | ((item: T) => ReactElement),\n  /** Values that should invalidate the item cache when using dynamic collections. */\n  dependencies?: any[]\n}\n\nfunction Section<T extends object>(props: SectionProps<T>, ref: ForwardedRef<HTMLElement>): JSX.Element | null {\n  let children = useCollectionChildren(props);\n  return useSSRCollectionNode('section', props, ref, null, children);\n}\n\nconst _Section = /*#__PURE__*/ (forwardRef as forwardRefType)(Section);\nexport {_Section as Section};\n\nexport const CollectionContext = createContext<CachedChildrenOptions<unknown> | null>(null);\nexport const CollectionRendererContext = createContext<CollectionProps<any>['children']>(null);\n\n/** A Collection renders a list of items, automatically managing caching and keys. */\nexport function Collection<T extends object>(props: CollectionProps<T>): JSX.Element {\n  let ctx = useContext(CollectionContext)!;\n  props = mergeProps(ctx, props);\n  props.dependencies = (ctx?.dependencies || []).concat(props.dependencies);\n  let renderer = typeof props.children === 'function' ? props.children : null;\n  return (\n    <CollectionRendererContext.Provider value={renderer}>\n      {useCollectionChildren(props)}\n    </CollectionRendererContext.Provider>\n  );\n}\n"],"names":[],"version":3,"file":"Collection.main.js.map"}