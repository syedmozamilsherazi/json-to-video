import {createPortal as $18I52$createPortal} from "react-dom";
import {useIsSSR as $18I52$useIsSSR, mergeProps as $18I52$mergeProps} from "react-aria";
import $18I52$react, {useMemo as $18I52$useMemo, cloneElement as $18I52$cloneElement, createContext as $18I52$createContext, useRef as $18I52$useRef, useCallback as $18I52$useCallback, useContext as $18I52$useContext, forwardRef as $18I52$forwardRef} from "react";
import {useSyncExternalStore as $18I52$useSyncExternalStore} from "use-sync-external-store/shim/index.js";

/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 



class $7135fc7d473fd974$export$f5d856d854e74713 {
    get childNodes() {
        throw new Error('childNodes is not supported');
    }
    clone() {
        let node = new $7135fc7d473fd974$export$f5d856d854e74713(this.type, this.key);
        node.value = this.value;
        node.level = this.level;
        node.hasChildNodes = this.hasChildNodes;
        node.rendered = this.rendered;
        node.textValue = this.textValue;
        node['aria-label'] = this['aria-label'];
        node.index = this.index;
        node.parentKey = this.parentKey;
        node.prevKey = this.prevKey;
        node.nextKey = this.nextKey;
        node.firstChildKey = this.firstChildKey;
        node.lastChildKey = this.lastChildKey;
        node.props = this.props;
        return node;
    }
    constructor(type, key){
        this.value = null;
        this.level = 0;
        this.hasChildNodes = false;
        this.rendered = null;
        this.textValue = '';
        this['aria-label'] = undefined;
        this.index = 0;
        this.parentKey = null;
        this.prevKey = null;
        this.nextKey = null;
        this.firstChildKey = null;
        this.lastChildKey = null;
        this.props = {};
        this.type = type;
        this.key = key;
    }
}
/**
 * A mutable node in the fake DOM tree. When mutated, it marks itself as dirty
 * and queues an update with the owner document.
 */ class $7135fc7d473fd974$var$BaseNode {
    *[Symbol.iterator]() {
        let node = this.firstChild;
        while(node){
            yield node;
            node = node.nextSibling;
        }
    }
    get firstChild() {
        return this._firstChild;
    }
    set firstChild(firstChild) {
        this._firstChild = firstChild;
        this.ownerDocument.markDirty(this);
    }
    get lastChild() {
        return this._lastChild;
    }
    set lastChild(lastChild) {
        this._lastChild = lastChild;
        this.ownerDocument.markDirty(this);
    }
    get previousSibling() {
        return this._previousSibling;
    }
    set previousSibling(previousSibling) {
        this._previousSibling = previousSibling;
        this.ownerDocument.markDirty(this);
    }
    get nextSibling() {
        return this._nextSibling;
    }
    set nextSibling(nextSibling) {
        this._nextSibling = nextSibling;
        this.ownerDocument.markDirty(this);
    }
    get parentNode() {
        return this._parentNode;
    }
    set parentNode(parentNode) {
        this._parentNode = parentNode;
        this.ownerDocument.markDirty(this);
    }
    get isConnected() {
        var _this_parentNode;
        return ((_this_parentNode = this.parentNode) === null || _this_parentNode === void 0 ? void 0 : _this_parentNode.isConnected) || false;
    }
    appendChild(child) {
        this.ownerDocument.startTransaction();
        if (child.parentNode) child.parentNode.removeChild(child);
        if (this.firstChild == null) this.firstChild = child;
        if (this.lastChild) {
            this.lastChild.nextSibling = child;
            child.index = this.lastChild.index + 1;
            child.previousSibling = this.lastChild;
        } else {
            child.previousSibling = null;
            child.index = 0;
        }
        child.parentNode = this;
        child.nextSibling = null;
        this.lastChild = child;
        this.ownerDocument.markDirty(this);
        if (child.hasSetProps) // Only add the node to the collection if we already received props for it.
        // Otherwise wait until then so we have the correct id for the node.
        this.ownerDocument.addNode(child);
        this.ownerDocument.endTransaction();
        this.ownerDocument.queueUpdate();
    }
    insertBefore(newNode, referenceNode) {
        if (referenceNode == null) return this.appendChild(newNode);
        this.ownerDocument.startTransaction();
        if (newNode.parentNode) newNode.parentNode.removeChild(newNode);
        newNode.nextSibling = referenceNode;
        newNode.previousSibling = referenceNode.previousSibling;
        newNode.index = referenceNode.index;
        if (this.firstChild === referenceNode) this.firstChild = newNode;
        else if (referenceNode.previousSibling) referenceNode.previousSibling.nextSibling = newNode;
        referenceNode.previousSibling = newNode;
        newNode.parentNode = referenceNode.parentNode;
        let node = referenceNode;
        while(node){
            node.index++;
            node = node.nextSibling;
        }
        if (newNode.hasSetProps) this.ownerDocument.addNode(newNode);
        this.ownerDocument.endTransaction();
        this.ownerDocument.queueUpdate();
    }
    removeChild(child) {
        if (child.parentNode !== this) return;
        this.ownerDocument.startTransaction();
        let node = child.nextSibling;
        while(node){
            node.index--;
            node = node.nextSibling;
        }
        if (child.nextSibling) child.nextSibling.previousSibling = child.previousSibling;
        if (child.previousSibling) child.previousSibling.nextSibling = child.nextSibling;
        if (this.firstChild === child) this.firstChild = child.nextSibling;
        if (this.lastChild === child) this.lastChild = child.previousSibling;
        child.parentNode = null;
        child.nextSibling = null;
        child.previousSibling = null;
        child.index = 0;
        this.ownerDocument.removeNode(child);
        this.ownerDocument.endTransaction();
        this.ownerDocument.queueUpdate();
    }
    addEventListener() {}
    removeEventListener() {}
    constructor(ownerDocument){
        this._firstChild = null;
        this._lastChild = null;
        this._previousSibling = null;
        this._nextSibling = null;
        this._parentNode = null;
        this.ownerDocument = ownerDocument;
    }
}
class $7135fc7d473fd974$export$dc064fe9e59310fd extends $7135fc7d473fd974$var$BaseNode {
    get index() {
        return this._index;
    }
    set index(index) {
        this._index = index;
        this.ownerDocument.markDirty(this);
    }
    get level() {
        if (this.parentNode instanceof $7135fc7d473fd974$export$dc064fe9e59310fd) return this.parentNode.level + (this.node.type === 'item' ? 1 : 0);
        return 0;
    }
    updateNode() {
        var _this_previousSibling, _this_nextSibling, _this_firstChild, _this_lastChild;
        let node = this.ownerDocument.getMutableNode(this);
        node.index = this.index;
        node.level = this.level;
        node.parentKey = this.parentNode instanceof $7135fc7d473fd974$export$dc064fe9e59310fd ? this.parentNode.node.key : null;
        var _this_previousSibling_node_key;
        node.prevKey = (_this_previousSibling_node_key = (_this_previousSibling = this.previousSibling) === null || _this_previousSibling === void 0 ? void 0 : _this_previousSibling.node.key) !== null && _this_previousSibling_node_key !== void 0 ? _this_previousSibling_node_key : null;
        var _this_nextSibling_node_key;
        node.nextKey = (_this_nextSibling_node_key = (_this_nextSibling = this.nextSibling) === null || _this_nextSibling === void 0 ? void 0 : _this_nextSibling.node.key) !== null && _this_nextSibling_node_key !== void 0 ? _this_nextSibling_node_key : null;
        node.hasChildNodes = !!this.firstChild;
        var _this_firstChild_node_key;
        node.firstChildKey = (_this_firstChild_node_key = (_this_firstChild = this.firstChild) === null || _this_firstChild === void 0 ? void 0 : _this_firstChild.node.key) !== null && _this_firstChild_node_key !== void 0 ? _this_firstChild_node_key : null;
        var _this_lastChild_node_key;
        node.lastChildKey = (_this_lastChild_node_key = (_this_lastChild = this.lastChild) === null || _this_lastChild === void 0 ? void 0 : _this_lastChild.node.key) !== null && _this_lastChild_node_key !== void 0 ? _this_lastChild_node_key : null;
    }
    setProps(obj, ref, rendered) {
        let node = this.ownerDocument.getMutableNode(this);
        let { value: value, textValue: textValue, id: id, ...props } = obj;
        props.ref = ref;
        node.props = props;
        node.rendered = rendered;
        node.value = value;
        node.textValue = textValue || (typeof rendered === 'string' ? rendered : '') || obj['aria-label'] || '';
        if (id != null && id !== node.key) {
            if (this.hasSetProps) throw new Error('Cannot change the id of an item');
            node.key = id;
        }
        // If this is the first time props have been set, end the transaction started in the constructor
        // so this node can be emitted.
        if (!this.hasSetProps) {
            this.ownerDocument.addNode(this);
            this.ownerDocument.endTransaction();
            this.hasSetProps = true;
        }
        this.ownerDocument.queueUpdate();
    }
    get style() {
        return {};
    }
    hasAttribute() {}
    setAttribute() {}
    setAttributeNS() {}
    removeAttribute() {}
    constructor(type, ownerDocument){
        super(ownerDocument);
        this.nodeType = 8 // COMMENT_NODE (we'd use ELEMENT_NODE but React DevTools will fail to get its dimensions)
        ;
        this._index = 0;
        this.hasSetProps = false;
        this.node = new $7135fc7d473fd974$export$f5d856d854e74713(type, `react-aria-${++ownerDocument.nodeId}`);
        // Start a transaction so that no updates are emitted from the collection
        // until the props for this node are set. We don't know the real id for the
        // node until then, so we need to avoid emitting collections in an inconsistent state.
        this.ownerDocument.startTransaction();
    }
}
class $7135fc7d473fd974$export$408d25a4e12db025 {
    get size() {
        return this.keyMap.size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    *[Symbol.iterator]() {
        let node = this.firstKey != null ? this.keyMap.get(this.firstKey) : undefined;
        while(node){
            yield node;
            node = node.nextKey != null ? this.keyMap.get(node.nextKey) : undefined;
        }
    }
    getChildren(key) {
        let keyMap = this.keyMap;
        return {
            *[Symbol.iterator] () {
                let parent = keyMap.get(key);
                let node = (parent === null || parent === void 0 ? void 0 : parent.firstChildKey) != null ? keyMap.get(parent.firstChildKey) : null;
                while(node){
                    yield node;
                    node = node.nextKey != null ? keyMap.get(node.nextKey) : undefined;
                }
            }
        };
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        if (!node) return null;
        if (node.prevKey != null) {
            node = this.keyMap.get(node.prevKey);
            while(node && node.type !== 'item' && node.lastChildKey != null)node = this.keyMap.get(node.lastChildKey);
            var _node_key;
            return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;
        }
        return node.parentKey;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        if (!node) return null;
        if (node.type !== 'item' && node.firstChildKey != null) return node.firstChildKey;
        while(node){
            if (node.nextKey != null) return node.nextKey;
            if (node.parentKey != null) node = this.keyMap.get(node.parentKey);
            else return null;
        }
        return null;
    }
    getFirstKey() {
        return this.firstKey;
    }
    getLastKey() {
        let node = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
        while((node === null || node === void 0 ? void 0 : node.lastChildKey) != null)node = this.keyMap.get(node.lastChildKey);
        var _node_key;
        return (_node_key = node === null || node === void 0 ? void 0 : node.key) !== null && _node_key !== void 0 ? _node_key : null;
    }
    getItem(key) {
        var _this_keyMap_get;
        return (_this_keyMap_get = this.keyMap.get(key)) !== null && _this_keyMap_get !== void 0 ? _this_keyMap_get : null;
    }
    at() {
        throw new Error('Not implemented');
    }
    clone() {
        // We need to clone using this.constructor so that subclasses have the right prototype.
        // TypeScript isn't happy about this yet.
        // https://github.com/microsoft/TypeScript/issues/3841
        let Constructor = this.constructor;
        let collection = new Constructor();
        collection.keyMap = new Map(this.keyMap);
        collection.firstKey = this.firstKey;
        collection.lastKey = this.lastKey;
        return collection;
    }
    addNode(node) {
        if (this.frozen) throw new Error('Cannot add a node to a frozen collection');
        this.keyMap.set(node.key, node);
    }
    removeNode(key) {
        if (this.frozen) throw new Error('Cannot remove a node to a frozen collection');
        this.keyMap.delete(key);
    }
    commit(firstKey, lastKey, isSSR = false) {
        if (this.frozen) throw new Error('Cannot commit a frozen collection');
        this.firstKey = firstKey;
        this.lastKey = lastKey;
        this.frozen = !isSSR;
    }
    constructor(){
        this.keyMap = new Map();
        this.firstKey = null;
        this.lastKey = null;
        this.frozen = false;
    }
}
class $7135fc7d473fd974$export$b34a105447964f9f extends $7135fc7d473fd974$var$BaseNode {
    get isConnected() {
        return true;
    }
    createElement(type) {
        return new $7135fc7d473fd974$export$dc064fe9e59310fd(type, this);
    }
    /**
   * Lazily gets a mutable instance of a Node. If the node has already
   * been cloned during this update cycle, it just returns the existing one.
   */ getMutableNode(element) {
        let node = element.node;
        if (!this.mutatedNodes.has(element)) {
            node = element.node.clone();
            this.mutatedNodes.add(element);
            element.node = node;
        }
        this.markDirty(element);
        return node;
    }
    getMutableCollection() {
        if (!this.isSSR && !this.collectionMutated) {
            this.collection = this.collection.clone();
            this.collectionMutated = true;
        }
        return this.collection;
    }
    markDirty(node) {
        this.dirtyNodes.add(node);
    }
    startTransaction() {
        this.transactionCount++;
    }
    endTransaction() {
        this.transactionCount--;
    }
    addNode(element) {
        let collection = this.getMutableCollection();
        if (!collection.getItem(element.node.key)) {
            collection.addNode(element.node);
            for (let child of element)this.addNode(child);
        }
        this.markDirty(element);
    }
    removeNode(node) {
        for (let child of node)this.removeNode(child);
        let collection = this.getMutableCollection();
        collection.removeNode(node.node.key);
        this.markDirty(node);
    }
    /** Finalizes the collection update, updating all nodes and freezing the collection. */ getCollection() {
        if (this.transactionCount > 0) return this.collection;
        this.updateCollection();
        return this.collection;
    }
    updateCollection() {
        for (let element of this.dirtyNodes)if (element instanceof $7135fc7d473fd974$export$dc064fe9e59310fd && element.isConnected) element.updateNode();
        this.dirtyNodes.clear();
        if (this.mutatedNodes.size || this.collectionMutated) {
            var _this_firstChild, _this_lastChild;
            let collection = this.getMutableCollection();
            for (let element of this.mutatedNodes)if (element.isConnected) collection.addNode(element.node);
            var _this_firstChild_node_key, _this_lastChild_node_key;
            collection.commit((_this_firstChild_node_key = (_this_firstChild = this.firstChild) === null || _this_firstChild === void 0 ? void 0 : _this_firstChild.node.key) !== null && _this_firstChild_node_key !== void 0 ? _this_firstChild_node_key : null, (_this_lastChild_node_key = (_this_lastChild = this.lastChild) === null || _this_lastChild === void 0 ? void 0 : _this_lastChild.node.key) !== null && _this_lastChild_node_key !== void 0 ? _this_lastChild_node_key : null, this.isSSR);
            this.mutatedNodes.clear();
        }
        this.collectionMutated = false;
    }
    queueUpdate() {
        // Don't emit any updates if there is a transaction in progress.
        // queueUpdate should be called again after the transaction.
        if (this.dirtyNodes.size === 0 || this.transactionCount > 0) return;
        for (let fn of this.subscriptions)fn();
    }
    subscribe(fn) {
        this.subscriptions.add(fn);
        return ()=>this.subscriptions.delete(fn);
    }
    resetAfterSSR() {
        if (this.isSSR) {
            this.isSSR = false;
            this.firstChild = null;
            this.lastChild = null;
            this.nodeId = 0;
        }
    }
    constructor(collection){
        // @ts-ignore
        super(null);
        this.nodeType = 11 // DOCUMENT_FRAGMENT_NODE
        ;
        this.ownerDocument = this;
        this.dirtyNodes = new Set();
        this.isSSR = false;
        this.nodeId = 0;
        this.nodesByProps = new WeakMap();
        this.mutatedNodes = new Set();
        this.subscriptions = new Set();
        this.transactionCount = 0;
        this.collection = collection;
        this.collectionMutated = true;
    }
}
function $7135fc7d473fd974$export$727c8fc270210f13(props) {
    let { children: children, items: items, idScope: idScope, addIdAndValue: addIdAndValue, dependencies: dependencies = [] } = props;
    // Invalidate the cache whenever the parent value changes.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    let cache = (0, $18I52$useMemo)(()=>new WeakMap(), dependencies);
    return (0, $18I52$useMemo)(()=>{
        if (items && typeof children === 'function') {
            let res = [];
            for (let item of items){
                let rendered = cache.get(item);
                if (!rendered) {
                    rendered = children(item);
                    var _rendered_props_id, _ref;
                    // @ts-ignore
                    let key = (_ref = (_rendered_props_id = rendered.props.id) !== null && _rendered_props_id !== void 0 ? _rendered_props_id : item.key) !== null && _ref !== void 0 ? _ref : item.id;
                    // eslint-disable-next-line max-depth
                    if (key == null) throw new Error('Could not determine key for item');
                    // eslint-disable-next-line max-depth
                    if (idScope) key = idScope + ':' + key;
                    // Note: only works if wrapped Item passes through id...
                    rendered = /*#__PURE__*/ (0, $18I52$cloneElement)(rendered, addIdAndValue ? {
                        key: key,
                        id: key,
                        value: item
                    } : {
                        key: key
                    });
                    cache.set(item, rendered);
                }
                res.push(rendered);
            }
            return res;
        } else if (typeof children !== 'function') return children;
    }, [
        children,
        items,
        cache,
        idScope,
        addIdAndValue
    ]);
}
function $7135fc7d473fd974$export$901dbff4e54a6dd0(props) {
    return $7135fc7d473fd974$export$727c8fc270210f13({
        ...props,
        addIdAndValue: true
    });
}
const $7135fc7d473fd974$var$ShallowRenderContext = /*#__PURE__*/ (0, $18I52$createContext)(false);
function $7135fc7d473fd974$export$6cd28814d92fa9c9(props, initialCollection) {
    let { collection: collection, document: document } = $7135fc7d473fd974$export$7cd71aa5ddd6dc4e(initialCollection);
    let portal = $7135fc7d473fd974$export$ad42d5efb4461b31(props, document);
    return {
        portal: portal,
        collection: collection
    };
}
// React 16 and 17 don't support useSyncExternalStore natively, and the shim provided by React does not support getServerSnapshot.
// This wrapper uses the shim, but additionally calls getServerSnapshot during SSR (according to SSRProvider).
function $7135fc7d473fd974$var$useSyncExternalStoreFallback(subscribe, getSnapshot, getServerSnapshot) {
    let isSSR = (0, $18I52$useIsSSR)();
    let isSSRRef = (0, $18I52$useRef)(isSSR);
    // This is read immediately inside the wrapper, which also runs during render.
    // We just need a ref to avoid invalidating the callback itself, which
    // would cause React to re-run the callback more than necessary.
    // eslint-disable-next-line rulesdir/pure-render
    isSSRRef.current = isSSR;
    let getSnapshotWrapper = (0, $18I52$useCallback)(()=>{
        return isSSRRef.current ? getServerSnapshot() : getSnapshot();
    }, [
        getSnapshot,
        getServerSnapshot
    ]);
    return (0, $18I52$useSyncExternalStore)(subscribe, getSnapshotWrapper);
}
const $7135fc7d473fd974$var$useSyncExternalStore = typeof (0, $18I52$react)['useSyncExternalStore'] === 'function' ? (0, $18I52$react)['useSyncExternalStore'] : $7135fc7d473fd974$var$useSyncExternalStoreFallback;
function $7135fc7d473fd974$export$7cd71aa5ddd6dc4e(initialCollection) {
    // The document instance is mutable, and should never change between renders.
    // useSyncExternalStore is used to subscribe to updates, which vends immutable Collection objects.
    let document = (0, $18I52$useMemo)(()=>new $7135fc7d473fd974$export$b34a105447964f9f(initialCollection || new $7135fc7d473fd974$export$408d25a4e12db025()), [
        initialCollection
    ]);
    let subscribe = (0, $18I52$useCallback)((fn)=>document.subscribe(fn), [
        document
    ]);
    let getSnapshot = (0, $18I52$useCallback)(()=>{
        let collection = document.getCollection();
        if (document.isSSR) // After SSR is complete, reset the document to empty so it is ready for React to render the portal into.
        // We do this _after_ getting the collection above so that the collection still has content in it from SSR
        // during the current render, before React has finished the client render.
        document.resetAfterSSR();
        return collection;
    }, [
        document
    ]);
    let getServerSnapshot = (0, $18I52$useCallback)(()=>{
        document.isSSR = true;
        return document.getCollection();
    }, [
        document
    ]);
    let collection = $7135fc7d473fd974$var$useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    return {
        collection: collection,
        document: document
    };
}
const $7135fc7d473fd974$var$SSRContext = /*#__PURE__*/ (0, $18I52$createContext)(null);
const $7135fc7d473fd974$export$8c25dea96356a8b6 = /*#__PURE__*/ (0, $18I52$createContext)(null);
function $7135fc7d473fd974$export$ad42d5efb4461b31(props, document) {
    let ctx = (0, $18I52$useContext)($7135fc7d473fd974$export$8c25dea96356a8b6);
    let doc = document !== null && document !== void 0 ? document : ctx;
    let children = $7135fc7d473fd974$export$901dbff4e54a6dd0(props);
    let wrappedChildren = (0, $18I52$useMemo)(()=>/*#__PURE__*/ (0, $18I52$react).createElement($7135fc7d473fd974$var$ShallowRenderContext.Provider, {
            value: true
        }, children), [
        children
    ]);
    // During SSR, we render the content directly, and append nodes to the document during render.
    // The collection children return null so that nothing is actually rendered into the HTML.
    return (0, $18I52$useIsSSR)() ? /*#__PURE__*/ (0, $18I52$react).createElement($7135fc7d473fd974$var$SSRContext.Provider, {
        value: doc
    }, wrappedChildren) : /*#__PURE__*/ (0, $18I52$createPortal)(wrappedChildren, doc);
}
function $7135fc7d473fd974$export$813b5978dd974d8(props) {
    return /*#__PURE__*/ (0, $18I52$react).createElement((0, $18I52$react).Fragment, null, $7135fc7d473fd974$export$ad42d5efb4461b31(props));
}
function $7135fc7d473fd974$export$aeba0b1fb3dcd8b8(type, props, ref) {
    let isShallow = (0, $18I52$useContext)($7135fc7d473fd974$var$ShallowRenderContext);
    var _useSSRCollectionNode;
    if (isShallow) // Elements cannot be re-parented, so the context will always be there.
    // eslint-disable-next-line react-hooks/rules-of-hooks
    return (_useSSRCollectionNode = $7135fc7d473fd974$export$e7c29ae2353b16ea(type, props, ref, 'children' in props ? props.children : null)) !== null && _useSSRCollectionNode !== void 0 ? _useSSRCollectionNode : /*#__PURE__*/ (0, $18I52$react).createElement((0, $18I52$react).Fragment, null);
    return null;
}
function $7135fc7d473fd974$export$636783d3732b5559(props, ref, rendered) {
    // Return a callback ref that sets the props object on the fake DOM node.
    return (0, $18I52$useCallback)((element)=>{
        element === null || element === void 0 ? void 0 : element.setProps(props, ref, rendered);
    }, [
        props,
        ref,
        rendered
    ]);
}
function $7135fc7d473fd974$export$e7c29ae2353b16ea(Type, props, ref, rendered, children) {
    // During SSR, portals are not supported, so the collection children will be wrapped in an SSRContext.
    // Since SSR occurs only once, we assume that the elements are rendered in order and never re-render.
    // Therefore we can create elements in our collection document during render so that they are in the
    // collection by the time we need to use the collection to render to the real DOM.
    // After hydration, we switch to client rendering using the portal.
    let itemRef = $7135fc7d473fd974$export$636783d3732b5559(props, ref, rendered);
    let parentNode = (0, $18I52$useContext)($7135fc7d473fd974$var$SSRContext);
    if (parentNode) {
        // Guard against double rendering in strict mode.
        let element = parentNode.ownerDocument.nodesByProps.get(props);
        if (!element) {
            element = parentNode.ownerDocument.createElement(Type);
            element.setProps(props, ref, rendered);
            parentNode.appendChild(element);
            parentNode.ownerDocument.updateCollection();
            parentNode.ownerDocument.nodesByProps.set(props, element);
        }
        return children ? /*#__PURE__*/ (0, $18I52$react).createElement($7135fc7d473fd974$var$SSRContext.Provider, {
            value: element
        }, children) : null;
    }
    // @ts-ignore
    return /*#__PURE__*/ (0, $18I52$react).createElement(Type, {
        ref: itemRef
    }, children);
}
function $7135fc7d473fd974$var$Section(props, ref) {
    let children = $7135fc7d473fd974$export$901dbff4e54a6dd0(props);
    return $7135fc7d473fd974$export$e7c29ae2353b16ea('section', props, ref, null, children);
}
const $7135fc7d473fd974$export$6e2c8f0811a474ce = /*#__PURE__*/ (0, $18I52$forwardRef)($7135fc7d473fd974$var$Section);
const $7135fc7d473fd974$export$db36075d98ba73d3 = /*#__PURE__*/ (0, $18I52$createContext)(null);
const $7135fc7d473fd974$export$4feb769f8ddf26c5 = /*#__PURE__*/ (0, $18I52$createContext)(null);
function $7135fc7d473fd974$export$fb8073518f34e6ec(props) {
    let ctx = (0, $18I52$useContext)($7135fc7d473fd974$export$db36075d98ba73d3);
    props = (0, $18I52$mergeProps)(ctx, props);
    props.dependencies = ((ctx === null || ctx === void 0 ? void 0 : ctx.dependencies) || []).concat(props.dependencies);
    let renderer = typeof props.children === 'function' ? props.children : null;
    return /*#__PURE__*/ (0, $18I52$react).createElement($7135fc7d473fd974$export$4feb769f8ddf26c5.Provider, {
        value: renderer
    }, $7135fc7d473fd974$export$901dbff4e54a6dd0(props));
}


export {$7135fc7d473fd974$export$f5d856d854e74713 as NodeValue, $7135fc7d473fd974$export$dc064fe9e59310fd as ElementNode, $7135fc7d473fd974$export$408d25a4e12db025 as BaseCollection, $7135fc7d473fd974$export$b34a105447964f9f as Document, $7135fc7d473fd974$export$727c8fc270210f13 as useCachedChildren, $7135fc7d473fd974$export$901dbff4e54a6dd0 as useCollectionChildren, $7135fc7d473fd974$export$6cd28814d92fa9c9 as useCollection, $7135fc7d473fd974$export$7cd71aa5ddd6dc4e as useCollectionDocument, $7135fc7d473fd974$export$ad42d5efb4461b31 as useCollectionPortal, $7135fc7d473fd974$export$8c25dea96356a8b6 as CollectionDocumentContext, $7135fc7d473fd974$export$813b5978dd974d8 as CollectionPortal, $7135fc7d473fd974$export$aeba0b1fb3dcd8b8 as useShallowRender, $7135fc7d473fd974$export$e7c29ae2353b16ea as useSSRCollectionNode, $7135fc7d473fd974$export$636783d3732b5559 as useCollectionItemRef, $7135fc7d473fd974$export$6e2c8f0811a474ce as Section, $7135fc7d473fd974$export$db36075d98ba73d3 as CollectionContext, $7135fc7d473fd974$export$4feb769f8ddf26c5 as CollectionRendererContext, $7135fc7d473fd974$export$fb8073518f34e6ec as Collection};
//# sourceMappingURL=Collection.module.js.map
