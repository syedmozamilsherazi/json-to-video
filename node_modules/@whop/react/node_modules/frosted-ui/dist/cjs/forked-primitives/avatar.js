"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Root = exports.Image = exports.Fallback = exports.createAvatarScope = exports.AvatarImage = exports.AvatarFallback = exports.Avatar = void 0;
const tslib_1 = require("tslib");
const react_context_1 = require("@radix-ui/react-context");
const react_primitive_1 = require("@radix-ui/react-primitive");
const react_use_callback_ref_1 = require("@radix-ui/react-use-callback-ref");
const react_use_layout_effect_1 = require("@radix-ui/react-use-layout-effect");
const React = tslib_1.__importStar(require("react"));
/* -------------------------------------------------------------------------------------------------
 * Avatar
 * -----------------------------------------------------------------------------------------------*/
const AVATAR_NAME = 'Avatar';
const [createAvatarContext, createAvatarScope] = (0, react_context_1.createContextScope)(AVATAR_NAME);
exports.createAvatarScope = createAvatarScope;
const [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
const Avatar = React.forwardRef((props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = React.useState('idle');
    return (React.createElement(AvatarProvider, { scope: __scopeAvatar, imageLoadingStatus: imageLoadingStatus, onImageLoadingStatusChange: setImageLoadingStatus },
        React.createElement(react_primitive_1.Primitive.span, { ...avatarProps, ref: forwardedRef })));
});
exports.Avatar = Avatar;
Avatar.displayName = AVATAR_NAME;
/* -------------------------------------------------------------------------------------------------
 * AvatarImage
 * -----------------------------------------------------------------------------------------------*/
const IMAGE_NAME = 'AvatarImage';
const AvatarImage = React.forwardRef((props, forwardedRef) => {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    const { __scopeAvatar, src, onLoadingStatusChange = () => { }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps.referrerPolicy);
    const handleLoadingStatusChange = (0, react_use_callback_ref_1.useCallbackRef)((status) => {
        onLoadingStatusChange(status);
        context.onImageLoadingStatusChange(status);
    });
    (0, react_use_layout_effect_1.useLayoutEffect)(() => {
        if (imageLoadingStatus !== 'idle') {
            handleLoadingStatusChange(imageLoadingStatus);
        }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === 'loaded' ? React.createElement(react_primitive_1.Primitive.img, { ...imageProps, ref: forwardedRef, src: src }) : null;
});
exports.AvatarImage = AvatarImage;
AvatarImage.displayName = IMAGE_NAME;
/* -------------------------------------------------------------------------------------------------
 * AvatarFallback
 * -----------------------------------------------------------------------------------------------*/
const FALLBACK_NAME = 'AvatarFallback';
const AvatarFallback = React.forwardRef((props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = React.useState(delayMs === undefined);
    React.useEffect(() => {
        if (delayMs !== undefined) {
            const timerId = window.setTimeout(() => setCanRender(true), delayMs);
            return () => window.clearTimeout(timerId);
        }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== 'loaded' ? (React.createElement(react_primitive_1.Primitive.span, { ...fallbackProps, ref: forwardedRef })) : null;
});
exports.AvatarFallback = AvatarFallback;
AvatarFallback.displayName = FALLBACK_NAME;
/* -----------------------------------------------------------------------------------------------*/
function resolveLoadingStatus(image, src) {
    if (!image) {
        return 'idle';
    }
    if (!src) {
        return 'error';
    }
    if (image.src !== src) {
        image.src = src;
    }
    return image.complete && image.naturalWidth > 0 ? 'loaded' : 'loading';
}
function useImageLoadingStatus(src, referrerPolicy) {
    const isHydrated = useIsHydrated();
    const image = React.useRef(null);
    const img = (() => {
        if (!isHydrated)
            return null;
        if (!image.current) {
            image.current = new window.Image();
        }
        return image.current;
    })();
    const [loadingStatus, setLoadingStatus] = React.useState(() => resolveLoadingStatus(img, src));
    (0, react_use_layout_effect_1.useLayoutEffect)(() => {
        setLoadingStatus(resolveLoadingStatus(img, src));
    }, [img, src]);
    (0, react_use_layout_effect_1.useLayoutEffect)(() => {
        const updateStatus = (status) => () => {
            setLoadingStatus(status);
        };
        if (!img)
            return;
        const handleLoad = updateStatus('loaded');
        const handleError = updateStatus('error');
        img.addEventListener('load', handleLoad);
        img.addEventListener('error', handleError);
        if (referrerPolicy) {
            img.referrerPolicy = referrerPolicy;
        }
        return () => {
            img.removeEventListener('load', handleLoad);
            img.removeEventListener('error', handleError);
        };
    }, [img, referrerPolicy]);
    return loadingStatus;
}
function subscribe() {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    return () => { };
}
function useIsHydrated() {
    return React.useSyncExternalStore(subscribe, () => true, () => false);
}
const Root = Avatar;
exports.Root = Root;
const Image = AvatarImage;
exports.Image = Image;
const Fallback = AvatarFallback;
exports.Fallback = Fallback;
//# sourceMappingURL=avatar.js.map