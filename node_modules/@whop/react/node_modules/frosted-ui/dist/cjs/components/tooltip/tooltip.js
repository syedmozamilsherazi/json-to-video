"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tooltip = void 0;
const tslib_1 = require("tslib");
const classnames_1 = tslib_1.__importDefault(require("classnames"));
const radix_ui_1 = require("radix-ui");
const React = tslib_1.__importStar(require("react"));
const theme_1 = require("../../theme");
const text_1 = require("../text");
const tooltip_props_1 = require("./tooltip.props");
const Tooltip = (props) => {
    const { children, className, open, defaultOpen, onOpenChange, delayDuration, disableHoverableContent, content, container, forceMount, type = tooltip_props_1.tooltipPropDefs.type.default, ...tooltipContentProps } = props;
    const [isOverflowing, setIsOverflowing] = React.useState(false);
    const [triggerElement, setTriggerElement] = React.useState(null);
    React.useLayoutEffect(() => {
        if (type === 'overflow' && triggerElement) {
            const updateTriggerOverflow = () => {
                const isOverflowing = triggerElement.offsetWidth < triggerElement.scrollWidth ||
                    triggerElement.offsetHeight < triggerElement.scrollHeight;
                setIsOverflowing(isOverflowing);
            };
            updateTriggerOverflow();
            const resizeObserver = new ResizeObserver(() => {
                updateTriggerOverflow();
            });
            resizeObserver.observe(triggerElement);
            const mutationObserver = new MutationObserver(() => {
                updateTriggerOverflow();
            });
            mutationObserver.observe(triggerElement, {
                attributes: true,
                childList: true,
                subtree: true,
            });
            return () => {
                resizeObserver.disconnect();
                mutationObserver.disconnect();
            };
        }
        else {
            setIsOverflowing(false);
        }
    }, [triggerElement, type]);
    const rootProps = {
        open: open !== undefined ? (type === 'overflow' ? open && isOverflowing : open) : open,
        defaultOpen: defaultOpen !== undefined ? (type === 'overflow' ? defaultOpen && isOverflowing : defaultOpen) : defaultOpen,
        onOpenChange,
        delayDuration,
        disableHoverableContent,
    };
    return (React.createElement(radix_ui_1.Tooltip.Root, { ...rootProps },
        React.createElement(radix_ui_1.Tooltip.Trigger, { asChild: true, ref: (e) => {
                setTriggerElement(e);
            } }, children),
        React.createElement(radix_ui_1.Tooltip.Portal, { container: container, forceMount: forceMount }, (type === 'overflow' ? isOverflowing : true) ? (React.createElement(theme_1.Theme, { asChild: true },
            React.createElement(radix_ui_1.Tooltip.Content, { sideOffset: 4, collisionPadding: 10, ...tooltipContentProps, className: (0, classnames_1.default)('fui-TooltipContent', className) },
                React.createElement(text_1.Text, { as: "p", className: "fui-TooltipText", size: "1" }, content),
                React.createElement(radix_ui_1.Tooltip.Arrow, { className: "fui-TooltipArrow" })))) : null)));
};
exports.Tooltip = Tooltip;
Tooltip.displayName = 'Tooltip';
//# sourceMappingURL=tooltip.js.map