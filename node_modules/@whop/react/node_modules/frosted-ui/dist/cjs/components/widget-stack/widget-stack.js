"use strict";
'use client';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = exports.Root = exports.Prev = exports.Next = exports.Item = void 0;
exports.useWidgetStack = useWidgetStack;
exports.useWidgetStackItem = useWidgetStackItem;
const tslib_1 = require("tslib");
const classnames_1 = tslib_1.__importDefault(require("classnames"));
const React = tslib_1.__importStar(require("react"));
const radix_ui_1 = require("radix-ui");
const use_isomorphic_layout_effect_1 = require("../../helpers/use-isomorphic-layout-effect");
const widget_stack_props_1 = require("./widget-stack.props");
const WidgetStackContext = React.createContext({
    nextDisabled: false,
    setNextDisabled: () => null,
    prevDisabled: false,
    setPrevDisabled: () => null,
    controls: null,
    setControls: () => null,
    disableAutoPlay: false,
    setDisableAutoPlay: () => null,
    currentWidgetIndex: 0,
    setCurrentWidgetIndex: () => null,
    widgetsCount: 0,
    setWidgetsCount: () => null,
    orientation: undefined,
    autoPlay: undefined,
});
function _useWidgetStack() {
    const context = React.useContext(WidgetStackContext);
    if (context === undefined) {
        throw new Error('WidgetStackContext must be used within a WidgetStackRoot');
    }
    return context;
}
function useWidgetStack() {
    const context = React.useContext(WidgetStackContext);
    if (context === undefined) {
        throw new Error('WidgetStackContext must be used within a WidgetStackRoot');
    }
    const { nextDisabled, prevDisabled, currentWidgetIndex, widgetsCount, setDisableAutoPlay, controls } = context;
    const widgetStackContext = React.useMemo(() => {
        return {
            nextDisabled: nextDisabled,
            prevDisabled: prevDisabled,
            controls: controls
                ? {
                    prev: () => {
                        setDisableAutoPlay(true);
                        controls === null || controls === void 0 ? void 0 : controls.prev();
                    },
                    next: () => {
                        setDisableAutoPlay(true);
                        controls === null || controls === void 0 ? void 0 : controls.next();
                    },
                    scrollToIndex: (index) => {
                        setDisableAutoPlay(true);
                        controls === null || controls === void 0 ? void 0 : controls.scrollToIndex(index);
                    },
                }
                : null,
            currentWidgetIndex: currentWidgetIndex,
            widgetsCount: widgetsCount,
        };
    }, [nextDisabled, prevDisabled, currentWidgetIndex, widgetsCount, setDisableAutoPlay, controls]);
    return widgetStackContext;
}
const WidgetStackRoot = ({ children, orientation = widget_stack_props_1.widgetStackRootPropDefs.orientation.default, autoPlay, ...props }) => {
    const [controls, setControls] = React.useState(null);
    const [currentWidgetIndex, setCurrentWidgetIndex] = React.useState(0);
    const [nextDisabled, setNextDisabled] = React.useState(false);
    const [prevDisabled, setPrevDisabled] = React.useState(false);
    const [disableAutoPlay, setDisableAutoPlay] = React.useState(false);
    const [widgetsCount, setWidgetsCount] = React.useState(0);
    return (React.createElement(WidgetStackContext.Provider, { value: {
            controls,
            setControls,
            disableAutoPlay,
            setDisableAutoPlay,
            currentWidgetIndex,
            setCurrentWidgetIndex,
            nextDisabled,
            setNextDisabled,
            prevDisabled,
            setPrevDisabled,
            orientation,
            widgetsCount,
            setWidgetsCount,
            autoPlay,
        }, ...props }, children));
};
exports.Root = WidgetStackRoot;
WidgetStackRoot.displayName = 'WidgetStackRoot';
const WidgetStackStack = (props) => {
    const { className, children, ...rootProps } = props;
    const { currentWidgetIndex, orientation, setCurrentWidgetIndex, controls, setControls, setNextDisabled, setPrevDisabled, autoPlay, disableAutoPlay, setWidgetsCount, } = _useWidgetStack();
    const scrollAreaRef = React.useRef(null);
    (0, use_isomorphic_layout_effect_1.useIsomorphicLayoutEffect)(() => {
        setWidgetsCount(React.Children.toArray(children).filter(Boolean).length);
    }, [children]);
    const currentWidgetIndexRef = React.useRef(currentWidgetIndex);
    React.useEffect(() => {
        currentWidgetIndexRef.current = currentWidgetIndex;
    }, [currentWidgetIndex]);
    (0, use_isomorphic_layout_effect_1.useIsomorphicLayoutEffect)(() => {
        const scrollAreaElement = scrollAreaRef.current;
        if (!scrollAreaElement)
            return;
        const items = Array.from(scrollAreaElement.children);
        // ScrollIntoView animation is interrupted in Chrome
        // when you click a prev/next button that triggers the animation and turns disabled.
        // That's why scrollBy method is used instead.
        const dir = orientation === 'vertical' ? 'top' : 'left';
        const next = () => {
            const target = items[currentWidgetIndexRef.current + 1];
            if (target) {
                // get distance from top of scrollAreaElement to top of target
                const targetRect = target.getBoundingClientRect();
                const scrollAreaRect = scrollAreaElement.getBoundingClientRect();
                const distance = targetRect[dir] - scrollAreaRect[dir];
                scrollAreaElement.scrollBy({
                    [dir]: distance,
                    behavior: 'smooth',
                });
            }
        };
        const prev = () => {
            const target = items[currentWidgetIndexRef.current - 1];
            if (target) {
                // get distance from top of scrollAreaElement to top of target
                const targetRect = target.getBoundingClientRect();
                const scrollAreaRect = scrollAreaElement.getBoundingClientRect();
                const distance = targetRect[dir] - scrollAreaRect[dir];
                scrollAreaElement.scrollBy({
                    [dir]: distance,
                    behavior: 'smooth',
                });
            }
        };
        const scrollToIndex = (index) => {
            const target = items[index];
            if (target) {
                // get distance from top of scrollAreaElement to top of target
                const targetRect = target.getBoundingClientRect();
                const scrollAreaRect = scrollAreaElement.getBoundingClientRect();
                const distance = targetRect[dir] - scrollAreaRect[dir];
                console.log({ index, distance, target });
                scrollAreaElement.scrollBy({
                    [dir]: distance,
                    behavior: 'smooth',
                });
            }
        };
        setControls({
            next,
            prev,
            scrollToIndex,
        });
    }, [orientation]);
    const disableAutoPlayRef = React.useRef(disableAutoPlay);
    const directionRef = React.useRef('forward');
    const [isHovering, setIsHovering] = React.useState(false);
    React.useEffect(() => {
        disableAutoPlayRef.current = disableAutoPlay;
        if (!autoPlay || disableAutoPlay || isHovering)
            return;
        const scrollAreaElement = scrollAreaRef.current;
        if (!scrollAreaElement)
            return;
        const interval = setInterval(() => {
            if (disableAutoPlayRef.current)
                return;
            const scrollAreaElement = scrollAreaRef.current;
            if (!scrollAreaElement)
                return;
            const items = Array.from(scrollAreaElement.children);
            let scrollToIndex = directionRef.current === 'forward' ? currentWidgetIndexRef.current + 1 : currentWidgetIndexRef.current - 1;
            if (scrollToIndex < 0) {
                scrollToIndex = 1;
                directionRef.current = 'forward';
            }
            else if (scrollToIndex >= items.length) {
                scrollToIndex = items.length - 2;
                directionRef.current = 'backward';
            }
            if (directionRef.current === 'forward') {
                controls === null || controls === void 0 ? void 0 : controls.next();
            }
            else {
                controls === null || controls === void 0 ? void 0 : controls.prev();
            }
        }, autoPlay);
        return () => {
            clearInterval(interval);
        };
    }, [autoPlay, controls, isHovering, disableAutoPlay]);
    (0, use_isomorphic_layout_effect_1.useIsomorphicLayoutEffect)(() => {
        const scrollAreaElement = scrollAreaRef.current;
        if (!scrollAreaElement)
            return;
        const updateIntersectionRatios = () => {
            // check intersection ratio of each child
            const items = Array.from(scrollAreaElement.children);
            items.forEach((item) => {
                const targetScrollPosition = orientation === 'vertical' ? item.offsetTop : item.offsetLeft;
                const itemHeight = item.clientHeight;
                const scrollPosition = orientation === 'vertical' ? scrollAreaElement.scrollTop : scrollAreaElement.scrollLeft;
                const dist = Math.abs(targetScrollPosition - scrollPosition);
                const ratio = 1 - Math.min(dist / itemHeight, 1);
                item.style.setProperty('--intersection-ratio', ratio.toString());
            });
        };
        updateIntersectionRatios();
        scrollAreaElement.addEventListener('scroll', updateIntersectionRatios, {
            passive: true,
        });
        return () => {
            scrollAreaElement.removeEventListener('scroll', updateIntersectionRatios);
        };
    }, [children]);
    // Handle next/prev button states
    (0, use_isomorphic_layout_effect_1.useIsomorphicLayoutEffect)(() => {
        const scrollAreaElement = scrollAreaRef.current;
        if (!scrollAreaElement)
            return;
        const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                const target = entry.target;
                if (entry.isIntersecting) {
                    const items = Array.from(scrollAreaElement.children);
                    const index = items.indexOf(target);
                    if (index === 0) {
                        setPrevDisabled(true);
                        if (items.length > 1) {
                            setNextDisabled(false);
                        }
                    }
                    else if (index === items.length - 1) {
                        setNextDisabled(true);
                        if (items.length > 1) {
                            setPrevDisabled(false);
                        }
                    }
                    else {
                        setNextDisabled(false);
                        setPrevDisabled(false);
                    }
                    setCurrentWidgetIndex(index);
                }
            });
        }, {
            root: scrollAreaElement,
            rootMargin: '0px',
            threshold: 0.5,
        });
        Array.from(scrollAreaElement.children).forEach((child) => observer.observe(child));
        return () => {
            observer.disconnect();
        };
    }, [children]);
    return (React.createElement("div", { ...rootProps, className: (0, classnames_1.default)('fui-WidgetStackStack', className), onMouseEnter: () => setIsHovering(true), onMouseLeave: () => setIsHovering(false) },
        React.createElement("div", { className: "fui-WidgetStackScrollArea", "data-orientation": orientation, ref: scrollAreaRef }, children)));
};
exports.Stack = WidgetStackStack;
WidgetStackStack.displayName = 'WidgetStackStack';
const WidgetStackItemContext = React.createContext({
    isFullyVisible: false,
});
function useWidgetStackItem() {
    const context = React.useContext(WidgetStackItemContext);
    if (context === undefined) {
        throw new Error('WidgetStackItemContext must be used within a WidgetStackItem');
    }
    return context;
}
const WidgetStackItem = (props) => {
    const { className, children, ...rootProps } = props;
    const ref = React.useRef(null);
    const [isFullyVisible, setIsFullyVisible] = React.useState(false);
    (0, use_isomorphic_layout_effect_1.useIsomorphicLayoutEffect)(() => {
        const widgetElement = ref.current;
        const stackElement = widgetElement === null || widgetElement === void 0 ? void 0 : widgetElement.parentElement;
        if (!stackElement || !widgetElement)
            return;
        const observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                setIsFullyVisible(entry.intersectionRatio === 1);
            });
        }, {
            root: stackElement,
            rootMargin: '0px',
            threshold: [0, 1],
        });
        observer.observe(widgetElement);
        return () => {
            observer.disconnect();
        };
    }, [children]);
    return (React.createElement(WidgetStackItemContext.Provider, { value: { isFullyVisible } },
        React.createElement("div", { ...rootProps, ref: ref, className: (0, classnames_1.default)('fui-WidgetStackItem', className), role: "group", "aria-roledescription": "slide", "data-fully-visible": isFullyVisible ? 'true' : undefined, 
            // Disable focusing widget content when it's not fully visible
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            inert: isFullyVisible ? undefined : '' },
            React.createElement("div", { className: (0, classnames_1.default)('fui-WidgetStackItemContent') }, children))));
};
exports.Item = WidgetStackItem;
WidgetStackItem.displayName = 'WidgetStackItem';
const WidgetStackNext = (props) => {
    const { nextDisabled, controls } = useWidgetStack();
    return (React.createElement(radix_ui_1.Slot.Root, { ...props, 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore -- fix later
        disabled: nextDisabled, "data-disabled": nextDisabled || undefined, onClick: controls === null || controls === void 0 ? void 0 : controls.next }));
};
exports.Next = WidgetStackNext;
WidgetStackNext.displayName = 'WidgetStackNext';
const WidgetStackPrev = (props) => {
    const { prevDisabled, controls } = useWidgetStack();
    return (React.createElement(radix_ui_1.Slot.Root, { ...props, 
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore -- fix later
        disabled: prevDisabled, "data-disabled": prevDisabled || undefined, onClick: controls === null || controls === void 0 ? void 0 : controls.prev }));
};
exports.Prev = WidgetStackPrev;
WidgetStackPrev.displayName = 'WidgetStackPrev';
//# sourceMappingURL=widget-stack.js.map