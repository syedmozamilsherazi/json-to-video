'use client';
import { DirectionProvider } from '@radix-ui/react-direction';
import classNames from 'classnames';
import { Slot, Tooltip as TooltipPrimitive } from 'radix-ui';
import * as React from 'react';
import { getMatchingGrayColor, themePropDefs } from './theme-options';
import { WithThemeEvents } from './use-theme-events';
// eslint-disable-next-line @typescript-eslint/no-empty-function
const noop = () => { };
const ThemeContext = React.createContext(undefined);
function useThemeContext() {
    const context = React.useContext(ThemeContext);
    if (context === undefined) {
        throw new Error('`useThemeContext` must be used within a `Theme`');
    }
    return context;
}
const Theme = (props) => {
    const context = React.useContext(ThemeContext);
    const isRoot = context === undefined;
    if (isRoot) {
        return (React.createElement(TooltipPrimitive.Provider, null,
            React.createElement(DirectionProvider, { dir: "ltr" },
                React.createElement(ThemeRoot, { ...props }))));
    }
    return React.createElement(ThemeImpl, { ...props });
};
Theme.displayName = 'Theme';
const ThemeRoot = (props) => {
    const { appearance: appearanceProp = themePropDefs.appearance.default, accentColor: accentColorProp = themePropDefs.accentColor.default, grayColor: grayColorProp = themePropDefs.grayColor.default, infoColor: infoColorProp = themePropDefs.infoColor.default, successColor: successColorProp = themePropDefs.successColor.default, warningColor: warningColorProp = themePropDefs.warningColor.default, dangerColor: dangerColorProp = themePropDefs.dangerColor.default, hasBackground = themePropDefs.hasBackground.default, ...rootProps } = props;
    const [appearance, setAppearance] = React.useState(appearanceProp);
    React.useEffect(() => setAppearance(appearanceProp), [appearanceProp]);
    const [accentColor, setAccentColor] = React.useState(accentColorProp);
    React.useEffect(() => setAccentColor(accentColorProp), [accentColorProp]);
    const [grayColor, setGrayColor] = React.useState(grayColorProp);
    React.useEffect(() => setGrayColor(grayColorProp), [grayColorProp]);
    const [infoColor, setInfoColor] = React.useState(infoColorProp);
    React.useEffect(() => setInfoColor(infoColorProp), [infoColorProp]);
    const [successColor, setSuccessColor] = React.useState(successColorProp);
    React.useEffect(() => setSuccessColor(successColorProp), [successColorProp]);
    const [warningColor, setWarningColor] = React.useState(warningColorProp);
    React.useEffect(() => setWarningColor(warningColorProp), [warningColorProp]);
    const [dangerColor, setDangerColor] = React.useState(dangerColorProp);
    React.useEffect(() => setDangerColor(dangerColorProp), [dangerColorProp]);
    // Initial appearance on page load when `appearance` is explicitly set to `light` or `dark`
    const ExplicitRootAppearanceScript = React.memo(({ appearance }) => (React.createElement("script", { dangerouslySetInnerHTML: {
            __html: `!(function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');d.style.colorScheme='${appearance}';c.add('${appearance}');}catch(e){}})();`,
        } })), () => true);
    ExplicitRootAppearanceScript.displayName = 'ExplicitRootAppearanceScript';
    // Client-side only changes when `appearance` prop is changed while developing
    React.useEffect(() => updateThemeAppearanceClass(appearanceProp), [appearanceProp]);
    const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;
    return (React.createElement(React.Fragment, null,
        appearance !== 'inherit' && (React.createElement(React.Fragment, null,
            React.createElement(ExplicitRootAppearanceScript, { appearance: appearance }),
            React.createElement(SyncRootElementAppearance, { appearance: appearance }))),
        hasBackground && (React.createElement("style", { dangerouslySetInnerHTML: {
                __html: `
:root, .light, .light-theme { --color-page-background: white; }
.dark, .dark-theme { --color-page-background: var(--${resolvedGrayColor}-1); }
body { background-color: var(--color-page-background); }
`,
            } })),
        React.createElement(ThemeImpl, { ...rootProps, isRoot: true, hasBackground: hasBackground, 
            //
            appearance: appearance, accentColor: accentColor, grayColor: grayColor, infoColor: infoColor, successColor: successColor, warningColor: warningColor, dangerColor: dangerColor, 
            //
            onAppearanceChange: setAppearance, onAccentColorChange: setAccentColor, onGrayColorChange: setGrayColor, onInfoColorChange: setInfoColor, onSuccessColorChange: setSuccessColor, onWarningColorChange: setWarningColor, onDangerColorChange: setDangerColor })));
};
ThemeRoot.displayName = 'ThemeRoot';
function SyncRootElementAppearance({ appearance }) {
    React.useEffect(() => {
        try {
            document.documentElement.style.colorScheme = appearance;
            const cl = document.documentElement.classList;
            const opposite = appearance === 'light' ? 'dark' : 'light';
            if (cl.contains(opposite))
                cl.remove(opposite);
            if (!cl.contains(appearance))
                cl.add(appearance);
        }
        catch (_a) {
            /* ignore errors */
        }
    }, [appearance]);
    return null;
}
const ThemeImpl = (props) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const context = React.useContext(ThemeContext);
    const { asChild, isRoot, hasBackground, 
    //
    appearance = (_a = context === null || context === void 0 ? void 0 : context.appearance) !== null && _a !== void 0 ? _a : themePropDefs.appearance.default, accentColor = (_b = context === null || context === void 0 ? void 0 : context.accentColor) !== null && _b !== void 0 ? _b : themePropDefs.accentColor.default, grayColor = (_c = context === null || context === void 0 ? void 0 : context.resolvedGrayColor) !== null && _c !== void 0 ? _c : themePropDefs.grayColor.default, dangerColor = (_d = context === null || context === void 0 ? void 0 : context.dangerColor) !== null && _d !== void 0 ? _d : themePropDefs.dangerColor.default, warningColor = (_e = context === null || context === void 0 ? void 0 : context.warningColor) !== null && _e !== void 0 ? _e : themePropDefs.warningColor.default, successColor = (_f = context === null || context === void 0 ? void 0 : context.successColor) !== null && _f !== void 0 ? _f : themePropDefs.successColor.default, infoColor = (_g = context === null || context === void 0 ? void 0 : context.infoColor) !== null && _g !== void 0 ? _g : themePropDefs.infoColor.default, 
    //
    onAppearanceChange = noop, onAccentColorChange = noop, onGrayColorChange = noop, onInfoColorChange = noop, onSuccessColorChange = noop, onWarningColorChange = noop, onDangerColorChange = noop, 
    //
    ...themeProps } = props;
    const Comp = asChild ? Slot.Root : 'div';
    const resolvedGrayColor = grayColor === 'auto' ? getMatchingGrayColor(accentColor) : grayColor;
    const isExplicitAppearance = props.appearance !== undefined && props.appearance !== 'inherit';
    const isExplicitGrayColor = props.grayColor !== undefined;
    const shouldHaveBackground = !isRoot && (hasBackground === true || (hasBackground !== false && (isExplicitAppearance || isExplicitGrayColor)));
    return (React.createElement(ThemeContext.Provider, { value: React.useMemo(() => ({
            appearance,
            accentColor,
            dangerColor,
            warningColor,
            successColor,
            infoColor,
            grayColor,
            resolvedGrayColor,
            //
            onAppearanceChange,
            onAccentColorChange,
            onGrayColorChange,
            onInfoColorChange,
            onSuccessColorChange,
            onWarningColorChange,
            onDangerColorChange,
        }), [
            appearance,
            accentColor,
            dangerColor,
            warningColor,
            successColor,
            infoColor,
            grayColor,
            resolvedGrayColor,
            //
            onAppearanceChange,
            onAccentColorChange,
            onGrayColorChange,
            onInfoColorChange,
            onSuccessColorChange,
            onWarningColorChange,
            onDangerColorChange,
        ]) },
        isRoot && React.createElement(WithThemeEvents, null),
        React.createElement(Comp, { "data-is-root-theme": isRoot ? 'true' : 'false', "data-accent-color": accentColor, "data-danger-color": dangerColor, "data-warning-color": warningColor, "data-success-color": successColor, "data-info-color": infoColor, "data-gray-color": resolvedGrayColor, "data-has-background": shouldHaveBackground ? 'true' : 'false', ...themeProps, className: classNames('frosted-ui', {
                // Only apply theme class to nested `Theme` sections.
                //
                // If it's the root `Theme`, we either rely on
                // - something else setting the theme class when root `appearance` is `inherit`
                // - our script setting it when root `appearance` is explicit
                light: !isRoot && appearance === 'light',
                dark: !isRoot && appearance === 'dark',
            }, themeProps.className) })));
};
ThemeImpl.displayName = 'ThemeImpl';
function updateThemeAppearanceClass(appearance) {
    if (appearance === 'inherit')
        return;
    const root = document.documentElement;
    if (root.classList.contains('light-theme') || root.classList.contains('dark-theme')) {
        root.classList.remove('light-theme', 'dark-theme');
        root.style.colorScheme = appearance;
        root.classList.add(`${appearance}-theme`);
    }
    if (root.classList.contains('light') || root.classList.contains('dark')) {
        root.classList.remove('light', 'dark');
        root.style.colorScheme = appearance;
        root.classList.add(appearance);
    }
}
export { Theme, updateThemeAppearanceClass, useThemeContext };
//# sourceMappingURL=theme.js.map