import { createContextScope } from '@radix-ui/react-context';
import { Primitive } from '@radix-ui/react-primitive';
import { useCallbackRef } from '@radix-ui/react-use-callback-ref';
import { useLayoutEffect } from '@radix-ui/react-use-layout-effect';
import * as React from 'react';
/* -------------------------------------------------------------------------------------------------
 * Avatar
 * -----------------------------------------------------------------------------------------------*/
const AVATAR_NAME = 'Avatar';
const [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
const [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
const Avatar = React.forwardRef((props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = React.useState('idle');
    return (React.createElement(AvatarProvider, { scope: __scopeAvatar, imageLoadingStatus: imageLoadingStatus, onImageLoadingStatusChange: setImageLoadingStatus },
        React.createElement(Primitive.span, { ...avatarProps, ref: forwardedRef })));
});
Avatar.displayName = AVATAR_NAME;
/* -------------------------------------------------------------------------------------------------
 * AvatarImage
 * -----------------------------------------------------------------------------------------------*/
const IMAGE_NAME = 'AvatarImage';
const AvatarImage = React.forwardRef((props, forwardedRef) => {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    const { __scopeAvatar, src, onLoadingStatusChange = () => { }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps.referrerPolicy);
    const handleLoadingStatusChange = useCallbackRef((status) => {
        onLoadingStatusChange(status);
        context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect(() => {
        if (imageLoadingStatus !== 'idle') {
            handleLoadingStatusChange(imageLoadingStatus);
        }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === 'loaded' ? React.createElement(Primitive.img, { ...imageProps, ref: forwardedRef, src: src }) : null;
});
AvatarImage.displayName = IMAGE_NAME;
/* -------------------------------------------------------------------------------------------------
 * AvatarFallback
 * -----------------------------------------------------------------------------------------------*/
const FALLBACK_NAME = 'AvatarFallback';
const AvatarFallback = React.forwardRef((props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = React.useState(delayMs === undefined);
    React.useEffect(() => {
        if (delayMs !== undefined) {
            const timerId = window.setTimeout(() => setCanRender(true), delayMs);
            return () => window.clearTimeout(timerId);
        }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== 'loaded' ? (React.createElement(Primitive.span, { ...fallbackProps, ref: forwardedRef })) : null;
});
AvatarFallback.displayName = FALLBACK_NAME;
/* -----------------------------------------------------------------------------------------------*/
function resolveLoadingStatus(image, src) {
    if (!image) {
        return 'idle';
    }
    if (!src) {
        return 'error';
    }
    if (image.src !== src) {
        image.src = src;
    }
    return image.complete && image.naturalWidth > 0 ? 'loaded' : 'loading';
}
function useImageLoadingStatus(src, referrerPolicy) {
    const isHydrated = useIsHydrated();
    const image = React.useRef(null);
    const img = (() => {
        if (!isHydrated)
            return null;
        if (!image.current) {
            image.current = new window.Image();
        }
        return image.current;
    })();
    const [loadingStatus, setLoadingStatus] = React.useState(() => resolveLoadingStatus(img, src));
    useLayoutEffect(() => {
        setLoadingStatus(resolveLoadingStatus(img, src));
    }, [img, src]);
    useLayoutEffect(() => {
        const updateStatus = (status) => () => {
            setLoadingStatus(status);
        };
        if (!img)
            return;
        const handleLoad = updateStatus('loaded');
        const handleError = updateStatus('error');
        img.addEventListener('load', handleLoad);
        img.addEventListener('error', handleError);
        if (referrerPolicy) {
            img.referrerPolicy = referrerPolicy;
        }
        return () => {
            img.removeEventListener('load', handleLoad);
            img.removeEventListener('error', handleError);
        };
    }, [img, referrerPolicy]);
    return loadingStatus;
}
function subscribe() {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    return () => { };
}
function useIsHydrated() {
    return React.useSyncExternalStore(subscribe, () => true, () => false);
}
const Root = Avatar;
const Image = AvatarImage;
const Fallback = AvatarFallback;
export { 
//
Avatar, AvatarFallback, AvatarImage, createAvatarScope, Fallback, Image, 
//
Root, };
//# sourceMappingURL=avatar.js.map